'use strict';

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _promptConfirm = require('prompt-confirm');

var _promptConfirm2 = _interopRequireDefault(_promptConfirm);

var _username = require('username');

var _username2 = _interopRequireDefault(_username);

var _prependFile = require('prepend-file');

var _prependFile2 = _interopRequireDefault(_prependFile);

var _mapValues = require('lodash/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _util = require('../util');

var _ghostContent = require('../ghost-content');

var _auth = require('./auth');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

_bluebird2.default.promisifyAll(_fs2.default);

const writeRevisions = (() => {
  var _ref = _asyncToGenerator(function* (revisionsFile, revisions) {
    const user = yield (0, _username2.default)();
    const host = _os2.default.hostname();
    let fullUser = [user, host].filter(Boolean).join('@');
    if (fullUser) {
      fullUser = ' by ' + fullUser;
    }
    const preamble = `# Synced ${new Date().toISOString()}${fullUser}`;

    return _bluebird2.default.fromCallback(function (cb) {
      (0, _prependFile2.default)(revisionsFile, [preamble, ...revisions, ''].join('\n'), cb);
    });
  });

  return function writeRevisions(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

const writeFile = rootFolderPath => (() => {
  var _ref2 = _asyncToGenerator(function* ({ file, content, deleted }) {
    const folderPath = _path2.default.join(rootFolderPath, ...file.split('/').slice(0, -1));
    const filePath = _path2.default.join(rootFolderPath, file);

    if (!deleted) {
      try {
        yield _fs2.default.statAsync(folderPath);
      } catch (e) {
        yield _fs2.default.mkdirAsync(folderPath, { recursive: true });
      }
      return _fs2.default.writeFileAsync(filePath, content);
    }

    try {
      return yield _fs2.default.unlinkAsync(filePath);
    } catch (e) {
      if (e.code === 'ENOENT') {
        return _bluebird2.default.resolve(true);
      }
      throw e;
    }
  });

  return function (_x3) {
    return _ref2.apply(this, arguments);
  };
})();

const updateFolder = projectLocation => (() => {
  var _ref3 = _asyncToGenerator(function* ({ files, revisions, binary }, folder) {
    const folderPath = _path2.default.join(projectLocation, folder);
    try {
      yield _fs2.default.statAsync(folderPath);
    } catch (e) {
      yield _fs2.default.mkdirAsync(folderPath, { recursive: true });
    }
    const revisionsFile = _path2.default.join(folderPath, _ghostContent.REVISIONS_FILE_NAME);
    yield writeRevisions(revisionsFile, revisions);

    if (binary) {
      files.forEach(function (data) {
        data.content = Buffer.from(data.content, 'base64');
      });
    }

    return _bluebird2.default.each(files, writeFile(folderPath));
  });

  return function (_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
})();

module.exports = (() => {
  var _ref4 = _asyncToGenerator(function* (botUrl) {
    botUrl = botUrl.replace(/\/+$/, '');

    // This also implicitly ensures we're inside of the bot project directory, and validates the bot URL
    _util.print.info(`Checking your login status with ${botUrl}...`);
    const token = yield (0, _auth.login)(botUrl);
    if (!token) {
      _util.print.warn('Login is required for this operation, exiting now.');
      return;
    }

    let config;
    try {
      const { data } = yield _axios2.default.get(`${botUrl}/api/ghost_content/export`, {
        headers: {
          authorization: `Bearer ${token}`
        }
      });
      config = data;
    } catch (err) {
      _util.print.error(err.message || 'Unknown error', 'while fetching ghost content.');
      return;
    }

    if (!config || !Object.keys(config).length) {
      _util.print.info('No pending ghost revisions, nothing to be done here.');
      return;
    }

    const confirm = yield new _promptConfirm2.default(`
  Running this command will override any untracked / uncommitted changes to the corresponding content files.
  It is recommended that you use version control system (like git) and commit any changes before proceeding.
  Are you sure you want to continue?
  `).run();

    if (!confirm) {
      return;
    }

    try {
      yield _bluebird2.default.props((0, _mapValues2.default)(config, updateFolder(_path2.default.resolve('.'))));
      _util.print.success(`
    All content synced successfully. You now need to redeploy your bot with the updated content to finish the sync procedure.
    If you're using version control system (like git) you should review the changes before committing.
    Please don't forget to include (commit, deploy) ${_ghostContent.REVISIONS_FILE_NAME} file(s).
    `);
    } catch (err) {
      _util.print.error(err.message || 'Unknown error', 'while applying ghost content.');
      _util.print.error('Your content files may be in inconsistent state.');
      _util.print.error('It is recommended to reset the changes (like git reset) and try again.');
    }
  });

  return function (_x6) {
    return _ref4.apply(this, arguments);
  };
})();
//# sourceMappingURL=ghost-sync.js.map