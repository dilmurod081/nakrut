{"version":3,"sources":["../../src/content/service.js"],"names":["getNewItemId","category","prefix","renderer","id","replace","prepareDb","knex","schema","createTable","table","string","primary","text","timestamp","defaults","contentDir","contentDataDir","module","exports","botfile","projectLocation","logger","ghostManager","categories","categoryById","fileById","getItemProviders","path","resolve","transformItemDbToApi","item","data","JSON","parse","formData","metadata","split","filter","i","length","transformItemApiToDb","result","stringify","join","listCategoryItems","categoryId","from","count","searchTerm","orderBy","query","where","orWhere","items","offset","limit","then","map","dumpDataToFile","_","pick","upsertFile","dumpAllDataToFiles","Promise","getCategorySchema","find","json","jsonSchema","ui","uiSchema","title","description","listAvailableCategories","get","row","Number","resolveRefs","Array","isArray","isObject","props","mapValues","isString","m","match","select","Error","computeData","computeMetadata","computePreviewText","fillComputedProps","expandedFormData","previewText","createOrUpdateCategoryItem","itemId","toLowerCase","body","isNewItemCreation","update","insert","createdBy","createdOn","date","now","categoryItemsCount","q","res","deleteCategoryItems","ids","some","whereIn","del","getItemDefault","getItem","providerRegex","pMatch","provider","args","categoryName","substr","fn","categoryTitle","categorySchema","getItems","queries","getItemsByMetadata","recomputeCategoriesMetadata","each","computedProps","loadData","fileName","debug","readDataForFile","err","warn","mapSeries","loadCategoryFromSchema","requiredFields","forEach","isNil","field","push","loadCategoriesFromPath","file","filePath","schemas","test","json5","fs","readFileSync","require","VError","readFile","info","init","mkdirp","sync","addRootFolder","filesGlob","files","fromCallback","cwd","cb","registerGetItemProvider","name"],"mappings":"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","file":"service.js","sourcesContent":["/**\n * The Content Manager is mainly in charge of storing and retrieving\n * all the content that is stored and known by the bot. The content includes (but is not limited to)\n * the messages that the bot sends to users.\n * @see {@link https://botpress.io/docs/10.0/getting_started/trivia_content/}\n * @namespace  ContentManager\n * @example\n * bp.contentManager\n */\n\nimport path from 'path'\nimport fs from 'fs'\n\nimport { VError } from 'verror'\n\nimport _ from 'lodash'\nimport Promise from 'bluebird'\nimport glob from 'glob'\nimport mkdirp from 'mkdirp'\nimport nanoid from 'nanoid'\nimport json5 from 'json5'\n\nimport helpers from '../database/helpers'\nimport { getInMemoryDb } from '../util'\n\nconst getNewItemId = category => {\n  const prefix = (category.renderer || category.id).replace(/^#/, '')\n  return `${prefix}-${nanoid(6)}`\n}\n\nconst prepareDb = async () => {\n  const knex = getInMemoryDb()\n\n  // NB! This is in-memory temprorary database\n  // It is freshly created so we know there are no tables\n  // We also use camelCased columns for convenience\n  await knex.schema.createTable('content_items', table => {\n    table.string('id').primary()\n    table.text('data')\n    table.text('formData')\n    table.text('metadata')\n    table.string('categoryId')\n    table.text('previewText')\n    table.string('createdBy')\n    table.timestamp('createdOn')\n  })\n\n  return knex\n}\n\nconst defaults = {\n  contentDir: './content',\n  contentDataDir: './content_data'\n}\n\nmodule.exports = async ({ botfile, projectLocation, logger, ghostManager }) => {\n  const categories = []\n  const categoryById = {}\n  const fileById = {}\n\n  const getItemProviders = {}\n\n  const contentDir = path.resolve(projectLocation, botfile.contentDir || defaults.contentDir)\n  const contentDataDir = path.resolve(projectLocation, botfile.contentDataDir || defaults.contentDataDir)\n\n  const knex = await prepareDb()\n\n  const transformItemDbToApi = item => {\n    if (!item) {\n      return item\n    }\n\n    return {\n      ...item,\n      data: JSON.parse(item.data),\n      formData: JSON.parse(item.formData),\n      metadata: (item.metadata || '').split('|').filter(i => i.length > 0)\n    }\n  }\n\n  const transformItemApiToDb = item => {\n    if (!item) {\n      return item\n    }\n\n    const result = { ...item }\n\n    if ('formData' in item) {\n      result.formData = JSON.stringify(item.formData)\n    }\n    if ('data' in item) {\n      result.data = JSON.stringify(item.data)\n    }\n    if ('metadata' in item) {\n      result.metadata = '|' + (item.metadata || []).filter(i => !!i).join('|') + '|'\n    }\n\n    return result\n  }\n\n  /**\n   * @typedef {Object} ContentManager~Element\n   * @memberOf ContentManager\n   */\n\n  /**\n   * @typedef {Object} ContentManager~CategorySchema\n   * @memberOf ContentManager\n   * @prop {Object} json The JSONSchema\n   * @prop {String} ui The UI JSONSchema\n   * @property {String} description\n   * @property {String} renderer The name of the Content Renderer\n   */\n\n  /**\n   * @typedef {Object} ContentManager~Category\n   * @memberOf ContentManager\n   * @prop {String} id\n   * @prop {String} title\n   * @property {String} description\n   * @property {Number} count The number of elements in that category\n   * @property {ContentManager~CategorySchema} schema\n   */\n\n  /**\n   * Returns the elements of a given category\n   * @param  {String} categoryId The category, for example `text` or `trivia`.\n   * @param  {Number} [options.from=0] Pagination parameter (where to start)\n   * @param  {Number} [options.count=50] Pagination parameter (how many elements to return)\n   * @param  {String} [options.searchTerm=] Only return the elements containing this term\n   * @param  {Array.<String>}  [options.orderBy=['createdOn']]    A list of properties to order the elements by.\n   * @return {ContentManager~Element[]}\n   * @public\n   * @memberOf! ContentManager\n   */\n  const listCategoryItems = async (categoryId, { from = 0, count = 50, searchTerm, orderBy = ['createdOn'] } = {}) => {\n    let query = knex('content_items')\n\n    if (categoryId) {\n      query = query.where({ categoryId })\n    }\n\n    if (searchTerm) {\n      query = query.where(function() {\n        this.where('metadata', 'like', `%${searchTerm}%`)\n          .orWhere('formData', 'like', `%${searchTerm}%`)\n          .orWhere('id', 'like', `%${searchTerm}%`)\n      })\n    }\n\n    const items = await query\n      .orderBy(...orderBy)\n      .offset(from)\n      .limit(count)\n      .then()\n\n    return items.map(transformItemDbToApi)\n  }\n\n  const dumpDataToFile = async categoryId => {\n    // TODO Do paging here and dump *everything*\n    const items = (await listCategoryItems(categoryId, { count: 10000 })).map(item =>\n      _.pick(item, 'id', 'formData', 'createdBy', 'createdOn')\n    )\n\n    await ghostManager.upsertFile(contentDataDir, fileById[categoryId], JSON.stringify(items, null, 2))\n  }\n\n  const dumpAllDataToFiles = () => Promise.map(categories, ({ id }) => dumpDataToFile(id))\n\n  /**\n   * Get the schema for a given category\n   * @param  {String} categoryId [description]\n   * @return {ContentManager~CategorySchema}\n   */\n  const getCategorySchema = categoryId => {\n    const category = _.find(categories, { id: categoryId })\n    if (category == null) {\n      return null\n    }\n\n    return {\n      json: category.jsonSchema,\n      ui: category.uiSchema,\n      title: category.title,\n      description: category.description,\n      renderer: category.renderer\n    }\n  }\n\n  /**\n   * Returns all the categories\n   * @public\n   * @return {ContentManager~Category[]}\n   * @memberOf! ContentManager\n   */\n  const listAvailableCategories = () =>\n    Promise.map(categories, async category => {\n      const count = await knex('content_items')\n        .where({ categoryId: category.id })\n        .count('* as count')\n        .get(0)\n        .then(row => (row && Number(row.count)) || 0)\n\n      return {\n        id: category.id,\n        title: category.title,\n        description: category.description,\n        count,\n        schema: getCategorySchema(category.id)\n      }\n    })\n\n  const resolveRefs = async data => {\n    if (!data) {\n      return data\n    }\n    if (Array.isArray(data)) {\n      return Promise.map(data, resolveRefs)\n    }\n    if (_.isObject(data)) {\n      return Promise.props(_.mapValues(data, resolveRefs))\n    }\n    if (_.isString(data)) {\n      const m = data.match(/^##ref\\((.*)\\)$/)\n      if (!m) {\n        return data\n      }\n      return knex('content_items')\n        .select('formData')\n        .where('id', m[1])\n        .then(result => {\n          if (!result || !result.length) {\n            throw new Error(`Error resolving reference: ID ${m[1]} not found.`)\n          }\n          return JSON.parse(result[0].formData)\n        })\n        .then(resolveRefs)\n    }\n    return data\n  }\n\n  const computeData = async (categoryId, formData) => {\n    const category = categoryById[categoryId]\n    if (!category) {\n      throw new Error(`Unknown category ${categoryId}`)\n    }\n    return !category.computeData ? formData : category.computeData(formData, computeData)\n  }\n\n  const computeMetadata = async (categoryId, formData) => {\n    const category = categoryById[categoryId]\n    if (!category) {\n      throw new Error(`Unknown category ${categoryId}`)\n    }\n    return !category.computeMetadata ? [] : category.computeMetadata(formData, computeMetadata)\n  }\n\n  const computePreviewText = async (categoryId, formData) => {\n    const category = categoryById[categoryId]\n    if (!category) {\n      throw new Error(`Unknown category ${categoryId}`)\n    }\n    return !category.computePreviewText ? 'No preview' : category.computePreviewText(formData, computePreviewText)\n  }\n\n  const fillComputedProps = async (category, formData) => {\n    if (formData == null) {\n      throw new Error('\"formData\" must be a valid object')\n    }\n\n    const expandedFormData = await resolveRefs(formData)\n\n    const data = await computeData(category.id, expandedFormData)\n    const metadata = await computeMetadata(category.id, expandedFormData)\n    const previewText = await computePreviewText(category.id, expandedFormData)\n\n    if (!_.isArray(metadata)) {\n      throw new Error('computeMetadata must return an array of strings')\n    }\n\n    if (!_.isString(previewText)) {\n      throw new Error('computePreviewText must return a string')\n    }\n\n    if (data == null) {\n      throw new Error('computeData must return a valid object')\n    }\n\n    return {\n      data,\n      metadata,\n      previewText\n    }\n  }\n\n  /**\n   * Creates or updates an [Element]{@link ContentManager~Element}\n   * @param  {String} [options.itemId=] The id of the element to add\n   * @param  {String} options.categoryId The category of the element\n   * @param  {Object} options.formData The content of the element\n   * @async\n   * @public\n   * @memberOf! ContentManager\n   */\n  const createOrUpdateCategoryItem = async ({ itemId, categoryId, formData }) => {\n    categoryId = categoryId && categoryId.toLowerCase()\n    const category = _.find(categories, { id: categoryId })\n\n    if (category == null) {\n      throw new Error(`Category \"${categoryId}\" is not a valid registered categoryId`)\n    }\n\n    const item = { formData, ...(await fillComputedProps(category, formData)) }\n    const body = transformItemApiToDb(item)\n\n    const isNewItemCreation = !itemId\n    if (isNewItemCreation) {\n      itemId = getNewItemId(category)\n    }\n\n    if (!isNewItemCreation) {\n      await knex('content_items')\n        .update(body)\n        .where({ id: itemId })\n        .then()\n    } else {\n      await knex('content_items').insert({\n        ...body,\n        createdBy: 'admin',\n        createdOn: helpers(knex).date.now(),\n        id: itemId,\n        categoryId\n      })\n    }\n\n    await dumpDataToFile(categoryId)\n    return itemId\n  }\n\n  const categoryItemsCount = categoryId => {\n    let q = knex('content_items')\n    if (categoryId && categoryId !== 'all') {\n      q = q.where({ categoryId })\n    }\n    return q.count('id as count').then(([res]) => Number(res.count))\n  }\n\n  const deleteCategoryItems = async ids => {\n    if (!_.isArray(ids) || _.some(ids, id => !_.isString(id))) {\n      throw new Error('Expected an array of Ids to delete')\n    }\n\n    await knex('content_items')\n      .whereIn('id', ids)\n      .del()\n      .then()\n\n    return dumpAllDataToFiles()\n  }\n\n  const getItemDefault = async id => {\n    return knex('content_items')\n      .where({ id })\n      .get(0)\n  }\n\n  /**\n   * Retrieves one item\n   * @param  {String} query Usually the id of the {@link ContentManager.Element},\n   * but can also be a call to a {@link ContentManager.ElementProvider}.\n   * @return {ContentManager.ElementProvider}\n   * @memberof! ContentManager\n   * @example\n   * await bp.contentManager.getItem('#!trivia-12345')\n   * await bp.contentManager.getItem('#trivia-random()')\n   */\n  const getItem = async query => {\n    const providerRegex = /-(.+)\\((.*)\\)$/i\n\n    const pMatch = query.match(providerRegex)\n    let item\n\n    if (pMatch) {\n      const provider = pMatch[1].toLowerCase()\n      const args = pMatch[2]\n      const categoryName = query.substr(0, query.length - pMatch[0].length)\n\n      const fn = getItemProviders[provider]\n\n      if (!fn) {\n        throw new Error(`Invalid content expression \"${query}\", did you forget to register the \"${provider}\" provider?`)\n      }\n\n      item = await fn(knex, categoryName, args)\n\n      if (_.isArray(item)) {\n        throw new Error(`Provider \"${provider}\" returned an array instead of an object`)\n      }\n    } else {\n      item = await getItemDefault(query)\n    }\n\n    if (!item) {\n      return null\n    }\n\n    const category = _.find(categories, { id: item.categoryId })\n\n    return {\n      ...transformItemDbToApi(item),\n      categoryTitle: category.title,\n      categorySchema: getCategorySchema(item.categoryId)\n    }\n  }\n\n  /**\n   * Retrieves multiple items\n   * @param  {String} query Comma-separted string where each part is\n   * the same as an argument to {@link ContentManager.getItem}.\n   * @return {Array<ContentManager.ElementProvider>}\n   * @memberof! ContentManager\n   * @example\n   * await bp.contentManager.getItems('#!trivia-12345,#!trivia-12346')\n   */\n  const getItems = queries => Promise.map(queries.split(','), getItem)\n\n  const getItemsByMetadata = async metadata => {\n    const items = await knex('content_items')\n      .where('metadata', 'like', '%|' + metadata + '|%')\n      .then()\n\n    return transformItemDbToApi(items)\n  }\n\n  /**\n   * Refreshes the content categories metadata internally.\n   * This must be called after using `loadCategoryFromSchema`\n   * @memberOf!  ContentManager\n   * @public\n   */\n  const recomputeCategoriesMetadata = async () => {\n    for (const { id: categoryId } of categories) {\n      await knex('content_items')\n        .select('id', 'formData')\n        .where('categoryId', categoryId)\n        .then()\n        .each(async ({ id, formData }) => {\n          const computedProps = await fillComputedProps(categoryById[categoryId], JSON.parse(formData))\n          return knex('content_items')\n            .where('id', id)\n            .update(transformItemApiToDb(computedProps))\n        })\n    }\n  }\n\n  const loadData = async category => {\n    const fileName = category.id + '.json'\n    fileById[category.id] = fileName\n\n    logger.debug(`Loading data for ${category.id} from ${fileName}`)\n    let data = []\n    try {\n      data = await readDataForFile(fileName)\n    } catch (err) {\n      logger.warn(`Error reading data from ${fileName}`, err)\n    }\n\n    data = await Promise.map(data, async item => ({\n      ...item,\n      categoryId: category.id,\n      id: item.id || getNewItemId(category)\n    }))\n\n    // TODO: use transaction\n    return Promise.mapSeries(data, item =>\n      knex('content_items')\n        .insert(transformItemApiToDb(item))\n        .then()\n    )\n  }\n\n  /**\n   * Loads a new category from a raw schema definition.\n   * *Important:* do not forget to call `ContentManager~recomputeCategoriesMetadata` after calling this\n   * @param  {ContentManager~Category} schema A schema definition\n   * @memberOf!  ContentManager\n   * @return {Object} Returns the loaded category schema\n   * @public\n   */\n  const loadCategoryFromSchema = async schema => {\n    const requiredFields = ['id', 'title', 'jsonSchema']\n\n    requiredFields.forEach(field => {\n      if (_.isNil(schema[field])) {\n        throw new Error(`\"${field}\" is required but missing in schema`)\n      }\n    })\n\n    schema.id = schema.id.toLowerCase()\n\n    if (categoryById[schema.id]) {\n      throw new Error(`There is already a form with id \"${schema.id}\"`)\n    }\n\n    if (!schema.jsonSchema.title) {\n      schema.jsonSchema.title = schema.title\n    }\n\n    categoryById[schema.id] = schema\n    categories.push(schema)\n\n    await loadData(schema)\n\n    return schema\n  }\n\n  const loadCategoriesFromPath = async file => {\n    const filePath = path.resolve(contentDir, './' + file)\n\n    let schemas = null\n\n    if (/\\.json$/i.test(filePath)) {\n      // Using JSON5 instead of regular JSON\n      schemas = json5.parse(fs.readFileSync(filePath, 'utf8'))\n    } else {\n      // Allows for registering .form.js files\n      schemas = require(filePath)\n    }\n\n    try {\n      if (_.isArray(schemas)) {\n        for (const schema of schemas) {\n          await loadCategoryFromSchema(schema)\n        }\n      } else {\n        await loadCategoryFromSchema(schemas)\n      }\n    } catch (err) {\n      throw new VError(err, `Error registering Content Element \"${file}\"`)\n    }\n  }\n\n  const readDataForFile = async fileName => {\n    const json = await ghostManager.readFile(contentDataDir, fileName)\n    if (!json) {\n      return []\n    }\n\n    try {\n      const data = JSON.parse(json)\n      if (!Array.isArray(data)) {\n        throw new Error(`${fileName} expected to contain array, contents ignored`)\n      }\n      logger.info(`Read ${data.length} item(s) from ${fileName}`)\n      return data\n    } catch (err) {\n      logger.warn(`Error reading data from ${fileName}`, err)\n      return []\n    }\n  }\n\n  const init = async () => {\n    mkdirp.sync(contentDataDir)\n    await ghostManager.addRootFolder(contentDataDir, { filesGlob: '**/*.json' })\n\n    // DEPRECATED: Files don't have to contain .form anymore\n    const files = await Promise.fromCallback(cb => glob('**/*.@(form.json|form.js|json|js)', { cwd: contentDir }, cb))\n\n    for (const file of files) {\n      try {\n        await loadCategoriesFromPath(file)\n      } catch (err) {\n        throw new VError(err, `[Content Manager] Could not register Content Element \"${file}\"`)\n      }\n    }\n\n    await recomputeCategoriesMetadata()\n  }\n\n  /**\n   * @callback ElementProvider\n   * @memberOf!  ContentManager\n   * @param {KnexInstance} knex An instance of Knex\n   * @param {String} category The name of the category\n   * @param {String} args A string with whatever was passed in the parans e.g. \"random(25)\"\n   * @example\nconst randomProvider = (knex, category, args) => {\nreturn knex('content_items')\n  .where({ categoryId: category })\n  .orderBy(knex.raw('random()'))\n  .limit(1)\n  .get(0)\n}\n   */\n\n  /**\n   * Register a new item provider, which is used when parsing query for {@link ContentManager~getItem}\n   * @param  {String} name The name of the provider, e.g. `random`\n   * @param  {ContentManager.ElementProvider} fn A content provider function\n   * @memberOf ContentManager\n   * @public\n   * @example\n// returns a random element from a given category\nconst randomProvider = (knex, category, args) => {\n  return knex('content_items')\n    .where({ categoryId: category })\n    .orderBy(knex.raw('random()'))\n    .limit(1)\n    .get(0)\n}\n\nbp.contentManager.registerGetItemProvider('random', randomProvider)\n   */\n  const registerGetItemProvider = (name, fn) => {\n    name = name.toLowerCase()\n    getItemProviders[name] = fn\n  }\n\n  return {\n    init,\n    listAvailableCategories,\n    getCategorySchema,\n\n    loadCategoryFromSchema,\n    recomputeCategoriesMetadata,\n\n    createOrUpdateCategoryItem,\n    listCategoryItems,\n    categoryItemsCount,\n    deleteCategoryItems,\n\n    getItem,\n    getItems,\n    getItemsByMetadata,\n\n    registerGetItemProvider\n  }\n}\n"]}