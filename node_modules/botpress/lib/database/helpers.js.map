{"version":3,"sources":["../../src/database/helpers.js"],"names":["isLite","knex","client","config","module","exports","dateParse","exp","raw","dateFormat","date","iso","toDate","toISOString","columnOrDateFormat","colOrDate","lite","sql","createTableIfNotExists","tableName","cb","schema","hasTable","then","exists","insertAndRetrieve","data","returnColumns","idColumnName","insert","returning","get","transaction","trx","transacting","select","id","where","limit","commit","catch","rollback","format","now","isBefore","d1","d2","isAfter","isBetween","d3","isSameDay","hourOfDay","bool","true","false","parse","value","json","set","obj","JSON","stringify"],"mappings":"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","file":"helpers.js","sourcesContent":["/**\n * Helpers for the [Botpress Database]{@link Database} running on [Knex]{@link http://knexjs.org/}\n * @public\n * @module DatabaseHelpers\n * @example\n * import { DatabaseHelpers } from 'botpress'\n * // or\n * const { DatabaseHelpers } from 'botpress'\n *\n * const helpers = DatabaseHelpers(await bp.db.get())\n */\n\n/*\n  The goal of these helpers is to generate SQL queries\n  that are valid for both SQLite and Postgres\n*/\n\nimport moment from 'moment'\n\nconst isLite = knex => {\n  return knex.client.config.client === 'sqlite3'\n}\n\nmodule.exports = knex => {\n  const dateParse = exp => {\n    return isLite(knex) ? knex.raw(`strftime('%Y-%m-%dT%H:%M:%fZ', ${exp})`) : knex.raw(exp)\n  }\n\n  const dateFormat = date => {\n    const iso = moment(date)\n      .toDate()\n      .toISOString()\n    return dateParse(`'${iso}'`)\n  }\n\n  const columnOrDateFormat = colOrDate => {\n    const lite = isLite(knex)\n\n    if (colOrDate.sql) {\n      return colOrDate.sql\n    }\n\n    if (typeof colOrDate === 'string') {\n      return lite ? dateParse(colOrDate) : `\"${colOrDate}\"`\n    }\n\n    return dateFormat(colOrDate)\n  }\n\n  return {\n    /**\n     * Returns whether or not the current database is SQLite\n     * @return {Boolean} Returns true if the database is SQLite, false if Postgres\n     */\n    isLite: () => isLite(knex),\n\n    /**\n     * **This is a workaround utility function**\n     * knex's createTableIfNotExists doesn't work with postgres\n     * https://github.com/tgriesser/knex/issues/1303\n     * @param  {String}   tableName Name of the table to create\n     * @param  {Function} Callback function. Identical to Knex's callback.\n     */\n    createTableIfNotExists: (tableName, cb) => {\n      return knex.schema.hasTable(tableName).then(exists => {\n        if (exists) {\n          return\n        }\n        return knex.schema.createTableIfNotExists(tableName, cb)\n      })\n    },\n\n    // only works for single insert beause of SQLite\n    insertAndRetrieve: (tableName, data, returnColumns = 'id', idColumnName = 'id') => {\n      // postgres supports 'returning' natively\n      if (!isLite(knex)) {\n        return knex(tableName)\n          .insert(data)\n          .returning(returnColumns)\n          .then()\n          .get(0)\n      }\n      return knex.transaction(trx =>\n        knex(tableName)\n          .insert(data)\n          .transacting(trx)\n          .then(() =>\n            knex\n              .select(knex.raw('last_insert_rowid() as id'))\n              .transacting(trx)\n              .then(([{ id }]) => {\n                if (returnColumns === idColumnName) {\n                  return id\n                }\n                return knex(tableName)\n                  .select(returnColumns)\n                  .where(idColumnName, id)\n                  .limit(1)\n                  .transacting(trx)\n                  .then()\n                  .get(0)\n              })\n          )\n          .then(trx.commit)\n          .catch(trx.rollback)\n      )\n    },\n\n    date: {\n      format: dateFormat,\n      now: () => (isLite(knex) ? knex.raw(\"strftime('%Y-%m-%dT%H:%M:%fZ', 'now')\") : knex.raw('now()')),\n\n      isBefore: (d1, d2) => {\n        d1 = columnOrDateFormat(d1)\n        d2 = columnOrDateFormat(d2)\n\n        return knex.raw(d1 + ' < ' + d2)\n      },\n\n      isAfter: (d1, d2) => {\n        d1 = columnOrDateFormat(d1)\n        d2 = columnOrDateFormat(d2)\n\n        return knex.raw(d1 + ' > ' + d2)\n      },\n\n      isBetween: (d1, d2, d3) => {\n        d1 = columnOrDateFormat(d1)\n        d2 = columnOrDateFormat(d2)\n        d3 = columnOrDateFormat(d3)\n\n        return knex.raw(`${d1} BETWEEN ${d2} AND ${d3}`)\n      },\n\n      isSameDay: (d1, d2) => {\n        d1 = columnOrDateFormat(d1)\n        d2 = columnOrDateFormat(d2)\n\n        return knex.raw(`date(${d1}) = date(${d2})`)\n      },\n\n      hourOfDay: date => {\n        date = columnOrDateFormat(date)\n        return isLite(knex) ? knex.raw(`strftime('%H', ${date})`) : knex.raw(`to_char(${date}, 'HH24')`)\n      }\n    },\n\n    bool: {\n      true: () => (isLite(knex) ? 1 : true),\n      false: () => (isLite(knex) ? 0 : false),\n      parse: value => (isLite(knex) ? !!value : value)\n    },\n\n    json: {\n      set: obj => {\n        return isLite(knex) ? obj && JSON.stringify(obj) : obj\n      },\n      get: obj => {\n        return isLite(knex) ? obj && JSON.parse(obj) : obj\n      }\n    }\n  }\n}\n"]}