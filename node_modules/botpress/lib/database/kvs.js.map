{"version":3,"sources":["../../src/database/kvs.js"],"names":["module","exports","knex","options","getSetCallback","betweenGetAndSetCallback","Promise","resolve","tableName","upsert","key","value","sql","params","keyCol","valueCol","modifiedOnCol","JSON","stringify","now","date","isLite","raw","get","path","where","limit","then","row","obj","parse","_","set","setValue","original","bootstrap","createTableIfNotExists","table","string","primary","text","timestamp"],"mappings":";;AAUA;;;;AACA;;;;AAEA;;;;;;AAEA;;;;;;AAMAA,OAAOC,OAAP,GAAiB,CAACC,IAAD,EAAOC,UAAU,EAAjB,KAAwB;AACvC,QAAMC,iBAAiBD,QAAQE,wBAAR,KAAqC,MAAMC,mBAAQC,OAAR,EAA3C,CAAvB;AACA,QAAMC,YAAYL,QAAQK,SAAR,IAAqB,KAAvC;;AAEA,QAAMC,SAAS,CAACC,GAAD,EAAMC,KAAN,KAAgB;AAC7B,QAAIC,GAAJ;;AAEA,UAAMC,SAAS;AACbL,eADa;AAEbM,cAAQ,KAFK;AAGbC,gBAAU,OAHG;AAIbC,qBAAe,aAJF;AAKbN,SALa;AAMbC,aAAOM,KAAKC,SAAL,CAAeP,KAAf,CANM;AAObQ,WAAK,uBAAQjB,IAAR,EAAckB,IAAd,CAAmBD,GAAnB;AAPQ,KAAf;;AAUA,QAAI,uBAAQjB,IAAR,EAAcmB,MAAd,EAAJ,EAA4B;AAC1BT,YAAO;;;OAAP;AAID,KALD,MAKO;AACLA,YAAO;;;;;OAAP;AAMD;;AAED,WAAOV,KAAKoB,GAAL,CAASV,GAAT,EAAcC,MAAd,CAAP;AACD,GA5BD;;AA8BA;;;;;;;;;;;;;;;AAeA,QAAMU,MAAM,CAACb,GAAD,EAAMc,IAAN,KACVtB,KAAKM,SAAL,EACGiB,KADH,CACS,EAAEf,GAAF,EADT,EAEGgB,KAFH,CAES,CAFT,EAGGC,IAHH,GAIGJ,GAJH,CAIO,CAJP,EAKGI,IALH,CAKQC,OAAO;AACX,QAAI,CAACA,GAAL,EAAU;AACR,aAAO,IAAP;AACD;;AAED,UAAMC,MAAMZ,KAAKa,KAAL,CAAWF,IAAIjB,KAAf,CAAZ;AACA,QAAI,CAACa,IAAL,EAAW;AACT,aAAOK,GAAP;AACD;;AAED,WAAOE,iBAAER,GAAF,CAAMM,GAAN,EAAWL,IAAX,CAAP;AACD,GAhBH,CADF;;AAmBA;;;;;;;;;;;;;;;AAeA,QAAMQ,MAAM,CAACtB,GAAD,EAAMC,KAAN,EAAaa,IAAb,KAAsB;AAChC,QAAI,CAACA,IAAL,EAAW;AACT,aAAOf,OAAOC,GAAP,EAAYC,KAAZ,CAAP;AACD;;AAED,UAAMsB,WAAWJ,OAAO;AACtB,UAAIL,IAAJ,EAAU;AACRO,yBAAEC,GAAF,CAAMH,GAAN,EAAWL,IAAX,EAAiBb,KAAjB;AACA,eAAOkB,GAAP;AACD,OAHD,MAGO;AACL,eAAOlB,KAAP;AACD;AACF,KAPD;;AASA,WAAOY,IAAIb,GAAJ,EAASiB,IAAT,CAAcO,YAAY9B,iBAAiBuB,IAAjB,CAAsB,MAAMlB,OAAOC,GAAP,EAAYuB,SAASC,YAAY,EAArB,CAAZ,CAA5B,CAA1B,CAAP;AACD,GAfD;;AAiBA,QAAMC,YAAY,MAChB,uBAAQjC,IAAR,EAAckC,sBAAd,CAAqC5B,SAArC,EAAgD6B,SAAS;AACvDA,UAAMC,MAAN,CAAa,KAAb,EAAoBC,OAApB;AACAF,UAAMG,IAAN,CAAW,OAAX;AACAH,UAAMI,SAAN,CAAgB,aAAhB;AACD,GAJD,CADF;;AAOA,SAAO,EAAElB,GAAF,EAAOS,GAAP,EAAYG,SAAZ,EAAP;AACD,CA5GD,C,CArBA","file":"kvs.js","sourcesContent":["/**\n * The KVS (Key-Value Store) serves as a convenient, high-level data storing mechanism.\n * The KVS is an abstraction layer on top of the configured [Botpress Database]{@link Database}\n * @public\n * @namespace KVS\n * @example\n * bp.kvs\n * bp.db.kvs // ⚠️ Deprecated, will be removed in Botpress 11\n */\n\nimport Promise from 'bluebird'\nimport _ from 'lodash'\n\nimport helpers from './helpers'\n\n/*\n  Possible options:\n    - betweenGetAndSetCallback: will be called between the get and the set\n    and wait for promise to resolve\n    - tableName: overrides the KVS table's name\n*/\nmodule.exports = (knex, options = {}) => {\n  const getSetCallback = options.betweenGetAndSetCallback || (() => Promise.resolve())\n  const tableName = options.tableName || 'kvs'\n\n  const upsert = (key, value) => {\n    let sql\n\n    const params = {\n      tableName,\n      keyCol: 'key',\n      valueCol: 'value',\n      modifiedOnCol: 'modified_on',\n      key,\n      value: JSON.stringify(value),\n      now: helpers(knex).date.now()\n    }\n\n    if (helpers(knex).isLite()) {\n      sql = `\n        INSERT OR REPLACE INTO :tableName: (:keyCol:, :valueCol:, :modifiedOnCol:)\n        VALUES (:key, :value, :now)\n      `\n    } else {\n      sql = `\n        INSERT INTO :tableName: (:keyCol:, :valueCol:, :modifiedOnCol:)\n        VALUES (:key, :value, :now)\n        ON CONFLICT (:keyCol:) DO UPDATE\n          SET :valueCol: = :value, :modifiedOnCol: = :now\n      `\n    }\n\n    return knex.raw(sql, params)\n  }\n\n  /**\n   * Returns the unserialized value stored at a given key\n   * @param  {String} key  The unique key where you want to get the value at\n   * @param  {String=} [path] If specified, returns the value at the path inside the retrieved object (if stored object was an object).\n   * @return {?*} Returns the unserialized object of any type stored at that key or null if it doesn't exist\n   * @example\n   * // Assuming 'user001' is an Object like `{ profile: { first_name: \"Sylvain\" } }`\n   * const first_name = await bp.kvs.get('user001', 'profile.first_name')\n   * const fullUser = await bp.kvs.get('user001')\n   *\n   * // You can also retrieve array elements\n   * const first_subscriber = await bp.kvs.get('subscribers', '[0].name')\n   * @memberOf! KVS\n   * @async\n   */\n  const get = (key, path) =>\n    knex(tableName)\n      .where({ key })\n      .limit(1)\n      .then()\n      .get(0)\n      .then(row => {\n        if (!row) {\n          return null\n        }\n\n        const obj = JSON.parse(row.value)\n        if (!path) {\n          return obj\n        }\n\n        return _.get(obj, path)\n      })\n\n  /**\n   * Serializes and stores any value at the specified key, and optionally set a value inside an existing object at `path`.\n   * @param  {String} key   The unique key of the value you want to store\n   * @param  {*} value The value to store. Note that if you provide an object or array, it will be serialized to JSON automatically.\n   * Therefore, you have to make sure that your object is serializable (i.e. it has no circular references)\n   * @param  {String=} [path]  The path inside the object to set the value (see example)\n   * @example\n   * const user = { profile: { name: 'Sylvain' } }\n   * await bp.kvs.set('user001', user)\n   *\n   * // You can later overwrite the `name` property directly\n   * await bp.kvs.set('user001', 'Sylvain Perron', 'name')\n   * @async\n   * @memberof! KVS\n   */\n  const set = (key, value, path) => {\n    if (!path) {\n      return upsert(key, value)\n    }\n\n    const setValue = obj => {\n      if (path) {\n        _.set(obj, path, value)\n        return obj\n      } else {\n        return value\n      }\n    }\n\n    return get(key).then(original => getSetCallback().then(() => upsert(key, setValue(original || {}))))\n  }\n\n  const bootstrap = () =>\n    helpers(knex).createTableIfNotExists(tableName, table => {\n      table.string('key').primary()\n      table.text('value')\n      table.timestamp('modified_on')\n    })\n\n  return { get, set, bootstrap }\n}\n"]}