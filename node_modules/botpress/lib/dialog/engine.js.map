{"version":3,"sources":["../../src/dialog/engine.js"],"names":["callSubflowRegex","MAX_STACK_SIZE","TRUEISH_WORDS","true","always","yes","compileExp","_","memoize","expr","VMScript","DialogEngine","constructor","flowProvider","stateManager","options","logger","onError","fn","errorHandlers","push","_flowsLoadingPromise","flows","defaultFlow","get","outputProcessors","actions","actionMetadataProviders","vm","VM","timeout","onBeforeCreated","onAfterCreated","onBeforeEnd","onBeforeNodeEnter","onBeforeSessionTimeout","on","_processMessage","stateId","event","loadFlows","context","_getOrCreateContext","state","getState","type","_processTimeout","setState","_trace","text","substr","currentFlow","Error","catchAllOnReceive","_processInstructions","catchAllNext","transition","_evaluateCondition","condition","_processNode","node","processMessage","e","forEach","errorHandler","jumpTo","flowName","nodeName","resetState","flow","_findFlow","_findNode","_setContext","startNode","hasJumped","flowStack","name","getCurrentPosition","_getContext","endFlow","_endFlow","loadAll","then","getFlows","registerOutputProcessor","processor","isNil","isFunction","send","isString","id","registerActionMetadataProvider","provider","includes","registerActions","fnMap","overwrite","keys","handler","metadata","isObject","extra","freeze","registerFunctions","getAvailableActions","values","filter","x","String","startsWith","map","userState","beforeCtx","Promise","fromCallback","run","callback","currentNodeTimeout","currentFlowTimeout","fallbackTimeoutNode","fallbackTimeoutFlow","switchedFlow","switchedNode","originalFlow","test","_gotoSubflow","_gotoPreviousFlow","concat","el","i","length","onEnter","onReceive","_transitionToNextNodes","nextNodes","next","nextNode","deleteState","subflow","subflowNode","match","pop","last","instructions","isArray","mapSeries","instruction","_invokeAction","chunks","split","trace","_dispatchOutput","value","slice","join","output","msg","message","originalEvent","flowContext","args","argsStr","tail","first","JSON","parse","actionCtx","s","mapValues","Mustache","render","err","error","ret","Object","isFrozen","throwIfNotFound","find","nodes","log","replace","debug","operation","reason","level","spc","repeat","module","exports"],"mappings":"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","file":"engine.js","sourcesContent":["import _ from 'lodash'\nimport Mustache from 'mustache'\nimport Promise from 'bluebird'\nimport { VM, VMScript } from 'vm2'\nimport mware from 'mware'\n\nconst callSubflowRegex = /(.+\\.flow\\.json)\\s?@?\\s?(.+)?/i // e.g. './login.flow.json' or './login.flow.json @ username'\nconst MAX_STACK_SIZE = 100\n\nconst TRUEISH_WORDS = {\n  true: true,\n  always: true,\n  yes: true\n}\n\nconst compileExp = _.memoize(expr => new VMScript(expr))\n\n/** The Dialog Engine (or Dialog Manager) is the component that\n handles the flow logic. It it responsible for executing flows, including\n executing the actions and flowing to the nodes, redirections etc.\n @namespace DialogEngine\n @example\n bp.dialogEngine.processMessage(...)\n */\nclass DialogEngine {\n  constructor({ flowProvider, stateManager, options, logger }) {\n    this.logger = logger\n    this.flowProvider = flowProvider\n    this.stateManager = stateManager\n\n    this._flowsLoadingPromise = null\n    this.flows = []\n    this.defaultFlow = _.get(options, 'defaultFlow') || 'main.flow.json'\n    this.outputProcessors = []\n    this.errorHandlers = []\n    this.actions = {}\n    this.actionMetadataProviders = []\n    this.vm = new VM({\n      timeout: 5000\n    })\n\n    /**\n     * @typedef {Function} DialogEngine~DialogMiddleware\n     * @param {object} ctx A mutable context object\n     * @param {function} next Call this to continue processing\n     */\n\n    /**\n     * Middleware triggered before a new session is started.\n     * > **Note:** This middleware allows you to alter `ctx.flowName` to change\n     * > which flow will be selected to start the conversation.\n     * @function DialogEngine#onBeforeCreated\n     * @param {DialogEngine~DialogMiddleware} middleware\n     * @example\nbp.dialogEngine.onBeforeCreated((ctx, next) => {\n  ctx.flowName = 'example.flow.json'\n  next()\n})\n     */\n    this.onBeforeCreated = mware()\n\n    /**\n     * Middleware triggered **after** a new session is started.\n     * `ctx` is not mutable.\n     * @function DialogEngine#onAfterCreated\n     * @param {DialogEngine~DialogMiddleware} middleware\n     * @example\nbp.dialogEngine.onAfterCreated((ctx, next) => {\n  // Do something here\n  next()\n})\n     */\n    this.onAfterCreated = mware()\n\n    /**\n     * Middleware triggered **before** a conversation is ended for any reason.\n     * `ctx` is not mutable.\n     * @function DialogEngine#onBeforeEnd\n     * @param {DialogEngine~DialogMiddleware} middleware\n     * @example\nbp.dialogEngine.onBeforeEnd((ctx, next) => {\n  // Do something here\n  next()\n})\n     */\n    this.onBeforeEnd = mware()\n\n    /**\n     * Middleware triggered **before** a node is entered (before the `onEnter` execution).\n     * > **⚠️ Warn:** It is **not** recommended to mutate `ctx.node` for now, it might break in a future version of Botpress.\n     * @function DialogEngine#onBeforeNodeEnter\n     * @param {DialogEngine~DialogMiddleware} middleware\n     * @example\nbp.dialogEngine.onBeforeNodeEnter((ctx, next) => {\n  // Do something here\n  next()\n})\n     */\n    this.onBeforeNodeEnter = mware()\n\n    /**\n     * Middleware triggered **before** a conversation/session times out.\n     * > **Note:** You can't prevent it from timing out at this point.\n     * > You also can't change the timeout behavior/location at this time.\n     * @function DialogEngine#onBeforeSessionTimeout\n     * @param {DialogEngine~DialogMiddleware} middleware\n     * @example\nbp.dialogEngine.onBeforeSessionTimeout((ctx, next) => {\n  // Do something here\n  next()\n})\n     */\n    this.onBeforeSessionTimeout = mware()\n\n    flowProvider.on('flowsChanged', () => {\n      this._flowsLoadingPromise = null\n      this.flows = []\n    })\n  }\n\n  async _processMessage(stateId, event) {\n    await this.loadFlows()\n\n    const context = await this._getOrCreateContext(stateId)\n    let state = await this.stateManager.getState(stateId)\n\n    if (event.type === 'bp_dialog_timeout') {\n      state = await this._processTimeout(stateId, state, context, event)\n\n      if (state != null) {\n        await this.stateManager.setState(stateId, state)\n      }\n\n      return state\n    }\n\n    this._trace('<~', 'RECV', `\"${(event.text || '').substr(0, 20)}\"`, context, state)\n\n    if (!context.currentFlow) {\n      throw new Error('Expected currentFlow to be defined for stateId=' + stateId)\n    }\n\n    const catchAllOnReceive = _.get(context, 'currentFlow.catchAll.onReceive')\n\n    if (catchAllOnReceive) {\n      this._trace('!!', 'KALL', '', context, state)\n      state = await this._processInstructions(catchAllOnReceive, state, event, context)\n    }\n\n    // If there's a 'next' defined in catchAll, this will try to match any condition and if it is matched it\n    // will run the node defined in the next instead of the current context node\n    const catchAllNext = _.get(context, 'currentFlow.catchAll.next')\n    if (catchAllNext) {\n      this._trace('..', 'KALL', '', context, state)\n      for (const transition of catchAllNext) {\n        if (this._evaluateCondition(transition.condition, state, event)) {\n          return this._processNode(stateId, state, context, transition.node, event)\n        }\n      }\n\n      this._trace('?X', 'KALL', '', context, state)\n    }\n\n    state = await this._processNode(stateId, state, context, context.node, event)\n\n    if (state != null) {\n      await this.stateManager.setState(stateId, state)\n    }\n\n    return state\n  }\n\n  /**\n   * Process a new incoming message from the user.\n   * This will execute and run the flow until the flow ends or gets paused by user input\n   * @param  {string} stateId The Id of the state.\n   *                          This is usually unique per user/group/channel, depending on the platform.\n   * @param  {BPIncomingEvent} event   The incoming event (message)\n   * @return {Promise<State>}         Returns a promise that resolves with the new state\n   *                                  when the flow is done processing\n   */\n  async processMessage(stateId, event) {\n    try {\n      await this._processMessage(stateId, event)\n    } catch (e) {\n      this.errorHandlers.forEach(errorHandler => errorHandler(e))\n    }\n  }\n\n  /**\n   * Make the stateId jump to the specified flow and node\n   * regardless of if there was already an active flow or not\n   * in execution. If there was already an active flow executing,\n   * this will override it. Note that by default, the current state\n   * will be preserved; if you wish to reset the state as well,\n   * set `resetState` to `true`.\n   * Note that this will not continue processing, i.e. the user must send a message or\n   * you should call {@link BotEngine#processMessage} manually to continue execution.\n   * @example\n   * // inside a bp.hear (...)\n   * await bp.dialogEngine.jumpTo(stateId, 'main.flow.json')\n   * await bp.dialogEngine.processMessage(stateId, event) // Continue processing\n   * @param  {string} stateId  The stateId of the user/channel/group to make jump.\n   * @param  {string} flowName The name of the flow, e.g. `main.flow.json`\n   * @param  {string} [nodeName=null] The name of the node to jump to. Defaults to the flow's entry point.\n   * @param  {boolean} [options.resetState=false] Whether or not the state should be reset\n   */\n  async jumpTo(stateId, flowName, nodeName = null, options) {\n    options = {\n      resetState: false,\n      ...options\n    }\n\n    await this.loadFlows()\n\n    const flow = await this._findFlow(flowName, true)\n\n    if (nodeName) {\n      // We're just calling for throwing if doesn't exist\n      DialogEngine._findNode(flow, nodeName, true)\n    }\n\n    await this._setContext(stateId, {\n      currentFlow: flow,\n      node: nodeName || flow.startNode,\n      hasJumped: true,\n      flowStack: [{ flow: flow.name, node: nodeName || flow.startNode }]\n    })\n\n    if (options.resetState) {\n      await this.stateManager.setState(stateId, {})\n    }\n  }\n\n  /**\n   * Get the current flow and node for a specific stateId\n   * @param  {string} stateId\n   * @return {{ flow: string, node: string }} Returns the current flow and node\n   */\n  async getCurrentPosition(stateId) {\n    const context = await this._getContext(stateId)\n\n    if (context) {\n      return {\n        flow: context.currentFlow && context.currentFlow.name,\n        node: context.node\n      }\n    }\n\n    return {\n      flow: null,\n      node: null\n    }\n  }\n\n  /**\n   * Ends the flow for a specific stateId if there's an active flow,\n   * otherwise does nothing.\n   * @param  {string} stateId [description]\n   */\n  async endFlow(stateId) {\n    return this._endFlow(stateId)\n  }\n\n  loadFlows() {\n    if (!this._flowsLoadingPromise) {\n      this._trace('**', 'LOAD', '')\n      this._flowsLoadingPromise = this.flowProvider.loadAll().then(flows => {\n        this.flows = flows\n      })\n    }\n\n    return this._flowsLoadingPromise\n  }\n\n  async getFlows() {\n    await this.loadFlows()\n    return this.flows\n  }\n\n  /**\n   * Registers a new output processor (there can be many, which all get triggered on output).\n   * @param {OutpoutProcessor} processor - Is an object with {id, send}\n   * @param {string} processor.id - The unique id of the processor\n   * @param {Function} processor.send - The `send` function of the processor\n   * @returns {void}\n   * @private\n   */\n  registerOutputProcessor(processor) {\n    if (_.isNil(processor) || !_.isFunction(processor.send) || !_.isString(processor.id)) {\n      throw new Error('Invalid processor. Processor must have a function `send` defined and a valid `id`')\n    }\n\n    // For now we only ever support a single output processor\n    // We might want many output processors in the future, for example to hook up a debugger or a test suite\n    this.outputProcessors = [processor]\n  }\n\n  /**\n   * @typedef {object} DialogEngine~ActionMetadata\n   * @var {string} title\n   * @var {string} description\n   * @var {boolean} required\n   * @var {string} default\n   * @var {string} type\n   * @private\n   */\n\n  /**\n   * A metadata provider returns metadata for an action or\n   * returns null, in which case other providers will be called\n   * @typedef {Function} DialogEngine~MetadataProvider\n   * @param {string} action The name of the action\n   * @returns {DialogEngine~ActionMetadata}\n   * @private\n   */\n\n  /**\n   * Adds a new provider of function metadata\n   * @param {DialogEngine~MetadataProvider} provider\n   * @returns {void}\n   * @private\n   */\n  registerActionMetadataProvider(provider) {\n    if (!_.isFunction(provider)) {\n      throw new Error('Expected the function metadata provider to be a function')\n    }\n\n    if (!this.actionMetadataProviders.includes(provider)) {\n      this.actionMetadataProviders.push(provider)\n    }\n  }\n\n  /**\n   * Introduce new actions to the Flows that they can call.\n   * @param {Object} fnMap\n   * @param {bool} [overwrite=false] - Whether or not it should overwrite existing actions with the same name.\n   * Note that if overwrite is false, an error will be thrown on conflict.\n   * @returns {Promise.<void>}\n   */\n  async registerActions(fnMap, overwrite = false) {\n    _.keys(fnMap).forEach(name => {\n      if (this.actions[name] && !overwrite) {\n        throw new Error(`There is already a function named \"${name}\" registered`)\n      }\n\n      let handler = fnMap[name]\n      let metadata = null\n\n      if (!_.isFunction(handler)) {\n        if (!_.isObject(handler) || !_.isFunction(handler.handler)) {\n          throw new Error(`Expected function \"${name}\" to be a function or an object with a 'hander' function`)\n        }\n\n        handler = handler.handler\n        metadata = { ...fnMap[name], name, handler: null }\n      }\n\n      for (const provider of this.actionMetadataProviders) {\n        const extra = provider(name)\n\n        if (extra) {\n          metadata = { ...extra, ...metadata }\n          break\n        }\n      }\n\n      this.actions[name] = {\n        name,\n        metadata,\n        fn: handler\n      }\n\n      // Make the method available in the conditions evaluation context\n      this.vm.freeze(handler, name)\n    })\n  }\n\n  /**\n   * @deprecated Use registerActions() instead\n   */\n  registerFunctions(fnMap, overwrite = false) {\n    return this.registerActions(fnMap, overwrite)\n  }\n\n  /**\n   * Returns all the available actions along with their metadata\n   * @private\n   */\n  getAvailableActions() {\n    return _.values(this.actions)\n      .filter(x => !String(x.name).startsWith('__'))\n      .map(x => ({ ...x, fn: null }))\n  }\n\n  onError = fn => this.errorHandlers.push(fn)\n\n  async _processTimeout(stateId, userState, context, event) {\n    const beforeCtx = { stateId }\n    await Promise.fromCallback(callback => this.onBeforeSessionTimeout.run(beforeCtx, callback))\n\n    const currentNodeTimeout = _.get(DialogEngine._findNode(context.currentFlow, context.node), 'timeoutNode')\n    const currentFlowTimeout = _.get(context, 'currentFlow.timeoutNode')\n    const fallbackTimeoutNode = DialogEngine._findNode(context.currentFlow, 'timeout')\n    const fallbackTimeoutFlow = await this._findFlow('timeout.flow.json')\n\n    if (currentNodeTimeout) {\n      this._trace('<>', 'SNDE', '', context)\n      userState = await this._processNode(stateId, userState, context, currentNodeTimeout, event)\n    } else if (currentFlowTimeout) {\n      this._trace('<>', 'SFLW', '', context)\n      userState = await this._processNode(stateId, userState, context, currentFlowTimeout, event)\n    } else if (fallbackTimeoutNode) {\n      this._trace('<>', 'DNDE', '', context)\n      userState = await this._processNode(stateId, userState, context, fallbackTimeoutNode.name, event)\n    } else if (fallbackTimeoutFlow) {\n      this._trace('<>', 'DFLW', '', context)\n      userState = await this._processNode(stateId, userState, context, fallbackTimeoutFlow.name, event)\n    } else {\n      this._trace('<>', 'NTHG', '', context)\n      userState = await this._endFlow(stateId)\n    }\n\n    return userState\n  }\n\n  async _processNode(stateId, userState, context, nodeName, event) {\n    let switchedFlow = false\n    let switchedNode = context.hasJumped\n    context = { ...context, hasJumped: false }\n\n    const originalFlow = context.currentFlow.name\n\n    if (callSubflowRegex.test(nodeName)) {\n      this._trace('>>', 'FLOW', `\"${nodeName}\"`, context, null)\n      context = await this._gotoSubflow(nodeName, context)\n      switchedFlow = true\n    } else if (nodeName && nodeName[0] === '#') {\n      // e.g. '#success'\n      this._trace('<<', 'FLOW', `\"${nodeName}\"`, context, null)\n      context = await this._gotoPreviousFlow(nodeName, context)\n      switchedFlow = true\n    } else if (context.node !== nodeName) {\n      this._trace('>>', 'FLOW', `\"${nodeName}\"`)\n      switchedNode = true\n      context = { ...context, node: nodeName }\n    } else if (context.node == null) {\n      // We just created the context\n      switchedNode = true\n      context = { ...context, node: context.currentFlow.startNode }\n    }\n\n    const node = DialogEngine._findNode(context.currentFlow, context.node)\n\n    if (!node || !node.name) {\n      userState = await this._endFlow(stateId)\n      return userState\n      // TODO Trace error\n      // throw new Error(`Could not find node \"${context.node}\" in flow \"${context.currentFlow.name}\"`)\n    }\n\n    if (switchedFlow || switchedNode) {\n      const flowStack = context.flowStack.concat({\n        flow: context.currentFlow.name,\n        node: context.node\n      })\n\n      // Flattens the stack to only include flow jumps, not node jumps\n      context = {\n        ...context,\n        // Flattens the stack to only include flow jumps, not node jumps\n        flowStack: flowStack.filter((el, i) => {\n          return i === flowStack.length - 1 || flowStack[i + 1].flow !== el.flow\n        })\n      }\n\n      if (context.flowStack.length >= MAX_STACK_SIZE) {\n        throw new Error(\n          `Exceeded maximum flow stack size (${MAX_STACK_SIZE}).\n         This might be due to an unexpected infinite loop in your flows.\n         Current flow: ${context.currentFlow.name}\n         Current node: ${context.node}`\n        )\n      }\n\n      await this._setContext(stateId, context)\n\n      const beforeCtx = { stateId, node }\n      await Promise.fromCallback(callback => this.onBeforeNodeEnter.run(beforeCtx, callback))\n\n      if (node.onEnter) {\n        this._trace('!!', 'ENTR', '', context, userState)\n        userState = await this._processInstructions(node.onEnter, userState, event, context)\n      }\n\n      if (!node.onReceive) {\n        this._trace('..', 'NOWT', '', context, userState)\n\n        if (node.type === 'skill-call' && originalFlow !== node.flow) {\n          userState = await this._processNode(stateId, userState, context, node.flow, event)\n        } else {\n          userState = await this._transitionToNextNodes(node, context, userState, stateId, event)\n        }\n      }\n    } else {\n      // i.e. we were already on that node before we received the message\n      if (node.onReceive) {\n        this._trace('!!', 'RECV', '', context, userState)\n        userState = await this._processInstructions(node.onReceive, userState, event, context)\n      }\n\n      this._trace('..', 'RECV', '', context, userState)\n\n      if (node.type === 'skill-call' && originalFlow !== node.flow) {\n        userState = await this._processNode(stateId, userState, context, node.flow, event)\n      } else {\n        userState = await this._transitionToNextNodes(node, context, userState, stateId, event)\n      }\n    }\n\n    return userState\n  }\n\n  async _transitionToNextNodes(node, context, userState, stateId, event) {\n    const nextNodes = node.next || []\n    for (const nextNode of nextNodes) {\n      if (this._evaluateCondition(nextNode.condition, userState, event)) {\n        this._trace('??', 'MTCH', `cond = \"${nextNode.condition}\"`, context)\n        if (/^end$/i.test(nextNode.node)) {\n          // Node \"END\" or \"end\" ends the flow (reserved keyword)\n          return this._endFlow(stateId)\n        } else {\n          return this._processNode(stateId, userState, context, nextNode.node, event)\n        }\n      }\n    }\n\n    if (!nextNodes.length) {\n      // You reach this if there were no next nodes, in which case we end the flow\n      return this._endFlow(stateId)\n    }\n\n    return userState\n  }\n\n  async _endFlow(stateId) {\n    const beforeCtx = { stateId }\n    await Promise.fromCallback(callback => this.onBeforeEnd.run(beforeCtx, callback))\n\n    this._trace('--', 'ENDF', '', null, null)\n    await this.stateManager.deleteState(stateId, ['context'])\n\n    return null\n  }\n\n  async _getOrCreateContext(stateId) {\n    let state = await this._getContext(stateId)\n\n    if (state && state.currentFlow) {\n      return state\n    }\n\n    const beforeCtx = { stateId, flowName: this.defaultFlow }\n    await Promise.fromCallback(callback => this.onBeforeCreated.run(beforeCtx, callback))\n\n    const flow = await this._findFlow(beforeCtx.flowName, true)\n\n    if (!flow) {\n      throw new Error(`Could not find the default flow \"${this.defaultFlow}\"`)\n    }\n\n    state = {\n      currentFlow: flow,\n      flowStack: [{ flow: flow.name, node: flow.startNode }]\n    }\n\n    await this._setContext(stateId, state)\n\n    await Promise.fromCallback(callback => this.onAfterCreated.run({ ...beforeCtx }, callback))\n\n    return state\n  }\n\n  _getContext(stateId) {\n    return this.stateManager.getState(stateId + '___context')\n  }\n\n  _setContext(stateId, state) {\n    return this.stateManager.setState(stateId + '___context', state)\n  }\n\n  async _gotoSubflow(nodeName, context) {\n    const [, subflow, subflowNode] = nodeName.match(callSubflowRegex)\n\n    const flow = await this._findFlow(subflow, true)\n\n    return {\n      ...context,\n      currentFlow: flow,\n      node: subflowNode || flow.startNode\n    }\n  }\n\n  async _gotoPreviousFlow(nodeName, context) {\n    if (!context.flowStack) {\n      context = { ...context, flowStack: [] }\n    } else {\n      const flowStack = [...context.flowStack]\n      const currentFlow = context.currentFlow.name\n      while (flowStack[flowStack.length - 1].flow === currentFlow) {\n        flowStack.pop()\n      }\n      context = { ...context, flowStack }\n    }\n\n    if (context.flowStack.length < 1) {\n      this._trace('Flow tried to go back to previous flow but there was none. Exiting flow.', context, null)\n      // TODO END FLOW\n      return context\n    }\n\n    let { flow, node } = _.last(context.flowStack)\n\n    if (nodeName !== '#') {\n      node = nodeName.substr(1)\n    }\n\n    return {\n      ...context,\n      currentFlow: await this._findFlow(flow, true),\n      node\n    }\n  }\n\n  async _processInstructions(instructions, userState, event, context) {\n    if (!_.isArray(instructions)) {\n      instructions = [instructions]\n    }\n\n    await Promise.mapSeries(instructions, async instruction => {\n      if (!_.isString(instruction) || !instruction.startsWith('say ')) {\n        userState = await this._invokeAction(instruction, userState, event, context)\n        return\n      }\n\n      const chunks = instruction.split(' ')\n      if (chunks.length < 2) {\n        this.trace('ERROR Invalid text instruction. Expected an instruction along \"say #text Something\"')\n        return\n      }\n\n      await this._dispatchOutput(\n        {\n          type: chunks[1], // e.g. \"#text\" or \"#!trivia-12342\"\n          value: chunks.slice(2).join(' ') // e.g. Any additional parameter provided to the template\n        },\n        userState,\n        event,\n        context\n      )\n    })\n\n    return userState\n  }\n\n  async _dispatchOutput(output, userState, event, context) {\n    const msg = String(output.type + (output.value || '')).substr(0, 20)\n    this._trace('~>', 'SEND', `\"${msg}\"`)\n\n    return Promise.map(this.outputProcessors, processor =>\n      processor.send({ message: output, state: userState, originalEvent: event, flowContext: context })\n    )\n  }\n\n  async _invokeAction(instruction, userState, event, context) {\n    let name = null\n    let args = {}\n\n    if (_.isString(instruction)) {\n      if (instruction.includes(' ')) {\n        const chunks = instruction.split(' ')\n        const argsStr = _.tail(chunks).join(' ')\n        name = _.first(chunks)\n        try {\n          args = JSON.parse(argsStr)\n          const actionCtx = { state: userState, s: userState, event: event, e: event }\n          args = _.mapValues(args, value => {\n            if (_.isString(value) && value.includes('{{')) {\n              try {\n                return Mustache.render(value, actionCtx)\n              } catch (err) {\n                this.logger.error(`Error rendering Mustache string ${value}: ${err.message}`)\n                return value\n              }\n            }\n\n            return value\n          })\n        } catch (err) {\n          throw new Error('ERROR function has invalid arguments (not a valid JSON string): ' + argsStr)\n        }\n      } else {\n        name = instruction\n      }\n    } else {\n      this._trace(`ERROR function is not a valid string`)\n    }\n\n    if (!this.actions[name]) {\n      this._trace(`ERROR function \"${name}\" not found`, context, userState)\n    } else {\n      try {\n        this._trace('!!', 'EXEC', `func \"${name}\"`, context, userState)\n        const ret = await this.actions[name].fn(Object.freeze(userState), event, args || {})\n\n        if (ret && _.isObject(ret)) {\n          if (Object.isFrozen(ret)) {\n            this._trace(\n              `ERROR function \"${name}\" returned the original (frozen) state. You should clone the state (see 'Object.assign()') instead of returning the original state.`,\n              context,\n              userState\n            )\n          } else {\n            this._trace('!!', 'SSET', '', context)\n            return ret\n          }\n        }\n      } catch (err) {\n        throw new Error(`ERROR function \"${name}\" thrown an error: ${err && err.message}`)\n      }\n    }\n\n    return userState\n  }\n\n  _evaluateCondition(condition, userState, event) {\n    if (TRUEISH_WORDS[condition] || condition === '') {\n      return true\n    }\n\n    const vm = this.vm\n    vm.freeze(userState, 's')\n    vm.freeze(userState, 'state')\n    vm.freeze(event, 'event')\n    vm.freeze(event, 'e')\n\n    try {\n      return !!vm.run(compileExp(condition))\n    } catch (err) {\n      throw new Error(`ERROR evaluating condition \"${condition}\": ${err.message}`)\n    }\n  }\n\n  static _findNode(flow, nodeName, throwIfNotFound = false) {\n    if (throwIfNotFound && !flow) {\n      throw new Error(`Could not find node ${nodeName} because the flow was not defined (null)`)\n    }\n\n    const node = _.find(flow.nodes, { name: nodeName })\n\n    if (throwIfNotFound && !node) {\n      throw new Error(`Could not find node \"${nodeName}\" in flow \"${flow.name}\"`)\n    }\n\n    return node\n  }\n\n  async _findFlow(flowName, throwIfNotFound = false) {\n    const flows = await this.getFlows()\n    const flow = _.find(flows, { name: flowName })\n\n    if (throwIfNotFound && !flow) {\n      throw new Error(`Could not find flow \"${flowName}\"`)\n    }\n\n    return flow\n  }\n\n  log(message, context) {\n    const flow = _.get(context, 'currentFlow.name', 'NONE').replace(/\\.flow\\.json$/i, '')\n    const node = (context && context.node) || 'NONE'\n    const msg = `Dialog: [${flow} – ${node}]\\t${message}`\n    this.logger.debug(msg)\n  }\n\n  /**\n   * Dialog: [flow] (node) \\t OP  RESN  \"Description\"\n   * @param message\n   * @param context\n   * @param state\n   * @private\n   */\n  _trace(operation, reason, message, context) {\n    if (this.logger.level !== 'debug') {\n      // don't do string formatting if we're not going to log it anyway\n      return\n    }\n\n    let flow = _.get(context, 'currentFlow.name', ' N/A ').replace(/\\.flow\\.json/i, '')\n    let node = (context && context.node) || ' N/A '\n\n    flow = flow.length > 13 ? flow.substr(0, 13) + '&' : flow\n    node = node.length > 13 ? node.substr(0, 13) + '&' : node\n\n    const spc = _.repeat(' ', 30 - flow.length - node.length)\n\n    const msg = `Dialog: [${flow}] (${node}) ${spc} ${operation}  ${reason} \\t ${message}`\n\n    this.logger.debug(msg)\n  }\n}\n\nmodule.exports = DialogEngine\n"]}