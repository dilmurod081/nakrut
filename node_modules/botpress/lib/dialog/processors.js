'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _mustache = require('mustache');

var _mustache2 = _interopRequireDefault(_mustache);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
  default: {
    id: 'send-message',
    send: ({ message, originalEvent, state, flowContext }) => {
      let rendered = message.value;

      let additionalData = { state };

      if (rendered && rendered.includes('{{')) {
        rendered = _mustache2.default.render(rendered, _extends({}, state, {
          event: _lodash2.default.pick(originalEvent, ['raw', 'text', 'type', 'platform', 'user']),
          _context: _extends({}, _lodash2.default.pick(flowContext, ['node', 'flowStack']), {
            currentFlow: _lodash2.default.pick(flowContext.currentFlow, ['name', 'version', 'startNode'])
          })
        }));
      }

      // Check if it's JSON
      // This form is supposed to be more performant compared to regex
      if (rendered && rendered[0] === '{' && rendered[rendered.length - 1] === '}') {
        additionalData = _extends({}, additionalData, JSON.parse(rendered));
      } else if (rendered) {
        additionalData = _extends({}, additionalData, { text: rendered });
      }

      return originalEvent.reply(message.type, additionalData);
    }
  }
};
//# sourceMappingURL=processors.js.map