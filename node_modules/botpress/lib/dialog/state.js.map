{"version":3,"sources":["../../src/dialog/state.js"],"names":["module","exports","db","isExpired","session","_upsertState","stateId","state","knex","get","h","params","tableName","JSON","stringify","now","date","sql","isLite","raw","_createEmptyState","_stateId","_createSession","getState","where","id","limit","then","parse","setState","Error","deleteState","substates","states","map","x","whereIn","del"],"mappings":"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","file":"state.js","sourcesContent":["/**\n * The Dialog State Manager is in charge of keeping track of the state\n * for all conversations. This is being used internally by the [Dialog Engine]{@link DialogEngine}\n * but is also exposed publicly if you need to programmatically alter the state of some conversations.\n * @namespace DialogStateManager\n * @example\n * bp.dialogEngine.stateManager\n */\n\nimport helpers from '../database/helpers'\nimport { isPlainObject } from 'lodash'\n\nmodule.exports = ({ db }) => {\n  const isExpired = session => {\n    return false // TODO Implement\n  }\n\n  const _upsertState = async (stateId, state) => {\n    const knex = await db.get()\n    const h = helpers(knex)\n\n    const params = {\n      tableName: 'dialog_sessions',\n      stateId,\n      state: JSON.stringify(state),\n      now: h.date.now()\n    }\n\n    const sql = h.isLite()\n      ? `\n        INSERT OR REPLACE INTO :tableName: (id, state, active_on)\n        VALUES (:stateId, :state, :now)\n      `\n      : `\n        INSERT INTO :tableName: (id, state, active_on, created_on)\n        VALUES (:stateId, :state, :now, :now)\n        ON CONFLICT (id) DO UPDATE\n          SET active_on = :now, state = :state\n      `\n\n    return knex.raw(sql, params)\n  }\n\n  const _createEmptyState = stateId => ({ _stateId: stateId })\n\n  const _createSession = async stateId => {\n    const knex = await db.get()\n    const h = helpers(knex)\n\n    const state = _createEmptyState(stateId)\n\n    const params = {\n      tableName: 'dialog_sessions',\n      stateId,\n      state: JSON.stringify(state),\n      now: h.date.now()\n    }\n\n    const sql = h.isLite()\n      ? `\n        INSERT OR REPLACE INTO :tableName: (id, state, active_on, created_on)\n        VALUES (:stateId, :state, :now, :now)\n      `\n      : `\n        INSERT INTO :tableName: (id, state, active_on, created_on)\n        VALUES (:stateId, :state, :now, :now)\n        ON CONFLICT (id) DO UPDATE\n          SET created_on = :now, active_on = :now, state = :state\n      `\n\n    await knex.raw(sql, params)\n\n    return state\n  }\n\n  /**\n   * Returns the current state of the conversation\n   * @param  {String} stateId\n   * @return {Object} The conversation state\n   * @async\n   * @memberof! DialogStateManager\n   * @example\n   * const state = await bp.dialogEngine.stateManager.getState(event.user.id)\n   */\n  const getState = async stateId => {\n    const knex = await db.get()\n\n    const session = await knex('dialog_sessions')\n      .where({ id: stateId })\n      .limit(1)\n      .then()\n      .get(0)\n\n    if (session) {\n      if (isExpired(session)) {\n        // TODO trigger time out\n        return _createSession(stateId)\n      } else {\n        return JSON.parse(session.state)\n      }\n    } else {\n      return _createSession(stateId)\n    }\n  }\n\n  /**\n   * Overwrites the state of a current conversation\n   * @param  {String} stateId\n   * @param {Object} state The conversation state\n   * @return {Object} The new state\n   * @async\n   * @memberof! DialogStateManager\n   */\n  const setState = (stateId, state) => {\n    if (state != null && !isPlainObject(state)) {\n      throw new Error('State must be a plain object')\n    }\n\n    return _upsertState(stateId, state != null ? state : _createEmptyState(stateId))\n  }\n\n  /**\n   * Deletes the state(s) and (optionally) the associated sub-states (for e.g. ___context sub-state)\n   * @param stateId The state to delete\n   * @param {Array<String>} [substates] Detaults to ['context']. If this is empty it will delete no substate\n   * @async\n   * @memberof! DialogStateManager\n   */\n  const deleteState = async (stateId, substates = ['context']) => {\n    const knex = await db.get()\n\n    const states = [stateId, ...substates.map(x => `${stateId}___${x}`)]\n\n    await knex('dialog_sessions')\n      .whereIn('id', states)\n      .del()\n      .then()\n  }\n\n  return {\n    getState,\n    setState,\n    deleteState\n  }\n}\n"]}