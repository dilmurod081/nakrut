{"version":3,"sources":["../../src/ghost-content/transparent.js"],"names":["Promise","promisifyAll","fs","mkdirpAsync","promisify","mkdirp","module","exports","logger","projectLocation","normalizeFolder","folderOptions","info","addRootFolder","rootFolder","options","normalizedFolderName","debug","upsertFile","folder","file","content","folderPath","filePath","path","join","fullFileFolder","dirname","then","writeFileAsync","catch","e","error","readFile","isBinary","readFileAsync","code","deleteFile","unlinkAsync","directoryListing","fileEndingPattern","pathsToOmit","accessAsync","fromCallback","cb","cwd","paths","filter","includes","getPending","getPendingWithContent"],"mappings":"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","file":"transparent.js","sourcesContent":["/*\n  Transparent Ghost Content Manager hs the same API but\n  proxies all calls directly to the FS.\n  It's used while in development.\n*/\n\nimport path from 'path'\nimport fs from 'fs'\nimport mkdirp from 'mkdirp'\nimport Promise from 'bluebird'\nimport glob from 'glob'\n\nimport { normalizeFolder as _normalizeFolder } from './util'\n\nPromise.promisifyAll(fs)\nconst mkdirpAsync = Promise.promisify(mkdirp)\n\nmodule.exports = ({ logger, projectLocation }) => {\n  const normalizeFolder = _normalizeFolder(projectLocation)\n\n  const folderOptions = {}\n\n  logger.info('[Ghost Content Manager] (transparent) Initialized')\n\n  return {\n    addRootFolder: (rootFolder, options = {}) => {\n      const { normalizedFolderName } = normalizeFolder(rootFolder)\n      logger.debug(`[Ghost Content Manager] (transparent) Added root folder ${normalizedFolderName}, doing nothing.`)\n      folderOptions[normalizedFolderName] = options\n    },\n\n    upsertFile: (folder, file, content) => {\n      const { folderPath } = normalizeFolder(folder)\n      const filePath = path.join(folderPath, file)\n      const fullFileFolder = path.dirname(filePath)\n      return mkdirpAsync(fullFileFolder)\n        .then(() => fs.writeFileAsync(filePath, content))\n        .catch(e => {\n          logger.error('[Ghost Content Manager] (transparent) upsertFile error', e)\n          throw e\n        })\n    },\n\n    readFile: (folder, file) => {\n      const { folderPath, normalizedFolderName } = normalizeFolder(folder)\n      const filePath = path.join(folderPath, file)\n      const isBinary = (folderOptions[normalizedFolderName] || {}).isBinary || false\n      return fs\n        .readFileAsync(filePath, isBinary ? null : 'utf8')\n        .catch({ code: 'ENOENT' }, () => null)\n        .catch(e => {\n          logger.error('[Ghost Content Manager] (transparent) readFile error', e)\n          throw e\n        })\n    },\n\n    deleteFile: (folder, file) => {\n      const { folderPath } = normalizeFolder(folder)\n      const filePath = path.join(folderPath, file)\n      return fs.unlinkAsync(filePath).catch(e => {\n        logger.error('[Ghost Content Manager] (transparent) deleteFile error', e)\n        throw e\n      })\n    },\n\n    directoryListing: (rootFolder, fileEndingPattern = '', pathsToOmit = []) => {\n      const { folderPath } = normalizeFolder(rootFolder)\n      return fs\n        .accessAsync(folderPath)\n        .then(\n          () =>\n            Promise.fromCallback(cb => glob(`**/*${fileEndingPattern}`, { cwd: folderPath }, cb)).then(paths =>\n              paths.filter(path => !pathsToOmit.includes(path))\n            ),\n          () => []\n        )\n        .catch(e => {\n          logger.error('[Ghost Content Manager] (transparent) directoryListing error', e)\n          throw e\n        })\n    },\n\n    getPending: () => ({}),\n\n    getPendingWithContent: () => ({})\n  }\n}\n"]}