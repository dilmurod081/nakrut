'use strict';

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const matches = (conditions, event) => {
  if (!_lodash2.default.isPlainObject(conditions)) {
    conditions = { text: conditions };
  }

  const pairs = _lodash2.default.toPairs(conditions);
  return _lodash2.default.every(pairs, ([key, comparrer]) => {
    const eventValue = _lodash2.default.get(event, key, null);

    if (_lodash2.default.isFunction(comparrer)) {
      return comparrer(eventValue, event) === true;
    } else if (_lodash2.default.isRegExp(comparrer)) {
      const matches = comparrer.test(eventValue);

      if (matches && _lodash2.default.isString(eventValue)) {
        if (_lodash2.default.isNil(event.captured)) {
          event.captured = [];
        }

        const a = _lodash2.default.tail(comparrer.exec(eventValue));
        a.forEach(m => event.captured.push(m));
      }

      return matches;
    } else {
      return _lodash2.default.isEqual(comparrer, eventValue);
    }
  });
};

const hear = (conditions, callback) => {
  return (event, next) => {
    let result = false;
    if (_lodash2.default.isFunction(conditions)) {
      result = conditions(event);
    } else if (_lodash2.default.isArray(conditions)) {
      for (const conditionsItem of conditions) {
        if (matches(conditionsItem, event)) {
          result = true;
          break;
        }
      }
    } else {
      result = matches(conditions, event);
    }

    if (result && _lodash2.default.isFunction(callback)) {
      if (callback.length <= 1) {
        if (_lodash2.default.isFunction(next)) {
          next();
        }
        callback(event);
      } else {
        callback(event, next);
      }
    } else {
      if (_lodash2.default.isFunction(next)) {
        next();
      }
    }
  };
};

module.exports = { hear, matches };
//# sourceMappingURL=listeners.js.map