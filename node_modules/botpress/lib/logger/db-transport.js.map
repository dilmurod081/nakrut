{"version":3,"sources":["../../src/logger/db-transport.js"],"names":["LOGS_FLUSH_INTERVAL","LOGS_CHUNK_SIZE","DbTransport","winston","Transport","constructor","opts","flushPromise","batches","doFlush","batch","shift","length","knex","db","get","batchInsert","then","err","unshift","flush","name","janitor","add","table","ttl","flushInterval","setInterval","log","level","message","meta","callback","row","created_on","date","format","Date","push","emit","catch","_query","limit","order","q","select","orderBy"],"mappings":"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","file":"db-transport.js","sourcesContent":["import winston from 'winston'\nimport ms from 'ms'\n\nimport { isEmpty } from 'lodash'\n\nimport helpers from '../database/helpers'\nimport { safeStringify } from '../util'\n\nconst LOGS_FLUSH_INTERVAL = ms('2s')\nconst LOGS_CHUNK_SIZE = 1000\n\nexport default class DbTransport extends winston.Transport {\n  constructor(opts) {\n    super(opts)\n    this.name = 'DBLogger'\n    this.db = opts.db\n\n    opts.janitor.add({\n      table: 'logs',\n      ttl: opts.ttl\n    })\n\n    this.flushInterval = setInterval(this.flush, LOGS_FLUSH_INTERVAL)\n  }\n\n  flushPromise = null\n  batches = []\n\n  doFlush = async () => {\n    const batch = this.batches.shift()\n\n    try {\n      if (!batch || !batch.length) {\n        return\n      }\n\n      const knex = await this.db.get()\n      await knex.batchInsert('logs', batch, LOGS_CHUNK_SIZE).then()\n    } catch (err) {\n      // We put the logs back on the queue in position 1\n      // so that the next call will insert them in the right order\n      // This works since `batchInsert` wraps the op in a transaction\n      this.batches.unshift(batch)\n    }\n  }\n\n  flush = async () => {\n    if (this.flushPromise) {\n      return // Previous flush is not done running\n    }\n\n    this.flushPromise = this.doFlush()\n\n    await this.flushPromise\n    this.flushPromise = null\n  }\n\n  log(level, message, meta, callback) {\n    if (!isEmpty(meta)) {\n      message += ` (meta=${safeStringify(meta)})`\n    }\n\n    this.db\n      .get()\n      .then(knex => {\n        const row = {\n          level,\n          message,\n          created_on: helpers(knex).date.format(new Date())\n        }\n\n        if (this.batches.length) {\n          this.batches[this.batches.length - 1].push(row)\n        } else {\n          this.batches.push([row])\n        }\n        this.emit('logged')\n        callback(null, true)\n      })\n      .catch(err => {\n        callback(err, null)\n      })\n  }\n\n  static async _query(db, limit = null, order = 'desc') {\n    const knex = await db.get()\n    let q = knex('logs')\n      .select('created_on as timestamp', 'level', 'message')\n      .orderBy('created_on', order)\n      .orderBy('id', order)\n    if (limit) {\n      q = q.limit(limit)\n    }\n    return q.then()\n  }\n}\n"]}