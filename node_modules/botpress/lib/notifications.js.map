{"version":3,"sources":["../src/notifications.js"],"names":["getOriginatingModule","origPrepareStackTrace","Error","prepareStackTrace","_","stack","err","shift","getFileName","notifications","knex","modules","logger","events","toDatabase","notification","id","message","level","module_id","moduleId","module_icon","icon","module_name","name","redirect_url","url","created_on","date","now","read","bool","false","archived","fromDatabase","row","Date","sound","parse","markAsRead","notificationId","where","update","true","then","markAllAsRead","getInbox","orderBy","limit","rows","map","getArchived","archive","archiveAll","_bindEvents","on","emit","create","redirectUrl","enableSound","includes","toLowerCase","callingFile","callingModuleRoot","module","find","mod","root","options","isString","settings","menuIcon","menuText","insert","logMessage","loggerLevel","info","load","send","exports"],"mappings":"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","file":"notifications.js","sourcesContent":["import _ from 'lodash'\nimport nanoid from 'nanoid'\n\nimport helpers from './database/helpers'\n\nimport { resolveModuleRootPath } from './util'\n\nconst getOriginatingModule = () => {\n  const origPrepareStackTrace = Error.prepareStackTrace\n  Error.prepareStackTrace = (_, stack) => stack\n\n  const err = new Error()\n  const stack = err.stack\n  Error.prepareStackTrace = origPrepareStackTrace\n  stack.shift()\n\n  return stack[1].getFileName()\n}\n\nconst notifications = ({ knex, modules, logger, events }) => {\n  const toDatabase = (knex, notification) => ({\n    id: notification.id,\n    message: notification.message,\n    level: notification.level,\n    module_id: notification.moduleId,\n    module_icon: notification.icon,\n    module_name: notification.name,\n    redirect_url: notification.url,\n    created_on: helpers(knex).date.now(),\n    read: helpers(knex).bool.false(),\n    archived: helpers(knex).bool.false()\n  })\n\n  const fromDatabase = (knex, row) => ({\n    id: row.id,\n    message: row.message,\n    level: row.level,\n    moduleId: row.module_id,\n    icon: row.module_icon,\n    name: row.module_name,\n    url: row.redirect_url,\n    date: new Date(row.created_on),\n    sound: false,\n    read: helpers(knex).bool.parse(row.read)\n  })\n\n  // TODO: a bunch of functions below doesn't use `await`, should they actually be `async`?\n\n  /**\n   * Marks a single notification as read (but doesn't archive it)\n   * @param  {string} notificationId The id of the notification to mark as read\n   * @return {Promise}\n   */\n  const markAsRead = async notificationId =>\n    knex('notifications')\n      .where({ id: notificationId })\n      .update({ read: helpers(knex).bool.true() })\n      .then()\n\n  /**\n   * Marks all notifications as read (but doesn't archive them)\n   * @return {Promise}\n   */\n  const markAllAsRead = async () =>\n    knex('notifications')\n      .update({ read: helpers(knex).bool.true() })\n      .then()\n\n  /**\n   * Get the top 100 (unseen) notifications\n   * @return {Promise<Array<Notification>>} The list of all unseen notifications\n   */\n  const getInbox = async () =>\n    knex('notifications')\n      .where({ archived: helpers(knex).bool.false() })\n      .orderBy('created_on', 'DESC')\n      .limit(100)\n      .then(rows => rows.map(row => fromDatabase(knex, row)))\n\n  /**\n   * Returns all archived notifications\n   * @return {Promise<Array<Notification>>} The list of all archived notifications\n   */\n  const getArchived = async () =>\n    knex('notifications')\n      .where({ archived: helpers(knex).bool.true() })\n      .orderBy('created_on', 'DESC')\n      .limit(100)\n      .then(rows => rows.map(row => fromDatabase(knex, row)))\n\n  /**\n * Archives a single notification\n * @param  {string} notificationId The id of the notification to archive\n * @return {Promise}\n */\n  const archive = async notificationId =>\n    knex('notifications')\n      .where({ id: notificationId })\n      .update({ archived: helpers(knex).bool.true() })\n      .then()\n\n  /**\n * Archives all notifications\n * @return {Promise}\n */\n  const archiveAll = async () =>\n    knex('notifications')\n      .update({ archived: helpers(knex).bool.true() })\n      .then()\n\n  // Internal use only\n  // Binds events to actions\n  const _bindEvents = () => {\n    events.on('notifications.getAll', async () => {\n      events.emit('notifications.all', await getInbox())\n    })\n\n    events.on('notifications.read', async id => {\n      await markAsRead(id)\n      events.emit('notifications.all', await getInbox())\n    })\n\n    events.on('notifications.allRead', async () => {\n      await markAllAsRead()\n      events.emit('notifications.all', await getInbox())\n    })\n\n    events.on('notifications.trashAll', async () => {\n      await archiveAll()\n      events.emit('notifications.all', await getInbox())\n    })\n  }\n\n  /**\n   * Create and append a new Notification in the Hub. Emits a `notifications.new` event.\n   * @param  {string} options.message     (required) The body message of the notification\n   * @param  {string} options.redirectUrl (optional) The URL the users will be redirected to\n   *                                      when clicking on the notification\n   * @param  {string} options.level       (optional) The level (info, success, error, warning). Defaults to `info`.\n   * @param  {bool} options.enableSound (optional) Whether the notification will trigger a buzzing sound\n   *                                    if a user is currently logged on the dashboard. (defaults to `false`)\n   * @return {Promise}\n   */\n  const create = async ({ message, redirectUrl, level, enableSound }) => {\n    if (!message || typeof message !== 'string') {\n      throw new Error(\"'message' is mandatory and should be a string\")\n    }\n\n    if (!level || typeof level !== 'string' || !_.includes(['info', 'error', 'success'], level.toLowerCase())) {\n      level = 'info'\n    } else {\n      level = level.toLowerCase()\n    }\n\n    const callingFile = getOriginatingModule()\n    const callingModuleRoot = callingFile && resolveModuleRootPath(callingFile)\n\n    const module = _.find(modules, mod => {\n      return mod.root === callingModuleRoot\n    })\n\n    let options = {\n      moduleId: 'botpress',\n      icon: 'view_module',\n      name: 'botpress',\n      url: _.isString(redirectUrl) ? redirectUrl : '/'\n    }\n\n    if (module) {\n      // because the bot itself can send notifications\n      options = {\n        moduleId: module.name,\n        icon: module.settings.menuIcon,\n        name: module.settings.menuText,\n        url: redirectUrl\n      }\n\n      if (!redirectUrl || typeof url !== 'string') {\n        options.url = `/modules/${module.name}`\n      }\n    }\n\n    const notification = {\n      id: nanoid(),\n      message: message,\n      level: level,\n      moduleId: options.moduleId,\n      icon: options.icon,\n      name: options.name,\n      url: options.url,\n      date: new Date(),\n      sound: enableSound || false,\n      read: false\n    }\n\n    await knex('notifications')\n      .insert(toDatabase(knex, notification))\n      .then()\n\n    if (logger) {\n      const logMessage = `[notification::${notification.moduleId}] ${notification.message}`\n      const loggerLevel = logger[level] || logger.info\n      loggerLevel(logMessage)\n    }\n\n    if (events) {\n      events.emit('notifications.new', notification)\n    }\n  }\n\n  return {\n    // ----> Start of legacy API (DEPRECATED as of Botpress 1.1)\n    load: getInbox,\n    send: ({ message, url, level, sound }) => {\n      return create({ message, redirectUrl: url, level, enableSound: sound })\n    },\n    // End of legacy API <---\n    markAsRead,\n    markAllAsRead,\n    archiveAll,\n    archive,\n    getInbox,\n    getArchived,\n    create,\n    // internal API\n    _bindEvents\n  }\n}\n\nmodule.exports = notifications\n"]}