{"version":3,"sources":["../../src/queues/memory.js"],"names":["MemoryQueue","constructor","name","logger","options","drain","queue","length","tick","Object","assign","retries","drainInterval","subscribers","_lock","_drain","setInterval","getQueueId","job","event","_","get","enqueue","isPriority","jobWrapped","id","timestamp","Date","unshift","push","dequeue","shift","cancelAll","jobQueueId","filter","item","peek","find","toDequeueIdx","findIndex","el","splice","queueId","Promise","mapSeries","fn","err","warn","message","error","subscribe"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;;;;;AAEe,MAAMA,WAAN,CAAkB;AAC/BC,cAAYC,IAAZ,EAAkBC,MAAlB,EAA0BC,UAAU,EAApC,EAAwC;AAAA,SAWxCC,KAXwC,GAWhC,MAAM;AACZ,WAAKC,KAAL,CAAWC,MAAX,GAAoB,CAApB,IAAyB,KAAKC,IAAL,EAAzB;AACD,KAbuC;;AACtC,SAAKN,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeK,OAAOC,MAAP,CAAc,EAAEC,SAAS,CAAX,EAAcC,eAAe,IAA7B,EAAd,EAAmDR,OAAnD,CAAf;AACA,SAAKE,KAAL,GAAa,EAAb;AACA,SAAKO,WAAL,GAAmB,EAAnB;AACA,SAAKC,KAAL,GAAa,EAAb;;AAEA,SAAKC,MAAL,GAAcC,YAAY,KAAKX,KAAjB,EAAwB,KAAKD,OAAL,CAAaQ,aAArC,CAAd;AACD;;AAMDK,aAAWC,GAAX,EAAgB;AACd,UAAMC,QAAQD,IAAIC,KAAJ,IAAaD,GAA3B;;AAEA,WACEE,iBAAEC,GAAF,CAAMF,KAAN,EAAa,SAAb,KACAC,iBAAEC,GAAF,CAAMF,KAAN,EAAa,aAAb,CADA,IAEAC,iBAAEC,GAAF,CAAMF,KAAN,EAAa,QAAb,CAFA,IAGAC,iBAAEC,GAAF,CAAMF,KAAN,EAAa,aAAb,CAHA,IAIAC,iBAAEC,GAAF,CAAMF,KAAN,EAAa,YAAb,CAJA,IAKAC,iBAAEC,GAAF,CAAMF,KAAN,EAAa,QAAb,CALA,IAMA,SAPF;AASD;;AAEDG,UAAQJ,GAAR,EAAaP,UAAU,CAAvB,EAA0BY,aAAa,KAAvC,EAA8C;AAC5C,UAAMC,aAAa,EAAEN,GAAF,EAAOO,IAAI,uBAAX,EAAqBC,WAAW,IAAIC,IAAJ,EAAhC,EAA4ChB,OAA5C,EAAnB;AACA,QAAIY,UAAJ,EAAgB;AACd,WAAKjB,KAAL,CAAWsB,OAAX,CAAmBJ,UAAnB;AACD,KAFD,MAEO;AACL,WAAKlB,KAAL,CAAWuB,IAAX,CAAgBL,UAAhB;AACD;AACD,SAAKhB,IAAL;AACD;;AAEDsB,YAAU;AACR,WAAO,KAAKxB,KAAL,CAAWyB,KAAX,EAAP;AACD;;AAEDC,YAAUd,GAAV,EAAe;AACb,UAAMe,aAAa,KAAKhB,UAAL,CAAgBC,GAAhB,CAAnB;AACA,SAAKZ,KAAL,GAAa,KAAKA,KAAL,CAAW4B,MAAX,CAAkBC,QAAQ,KAAKlB,UAAL,CAAgBkB,KAAKjB,GAArB,MAA8Be,UAAxD,CAAb;AACD;;AAEDG,OAAKlB,GAAL,EAAU;AACR,UAAMe,aAAa,KAAKhB,UAAL,CAAgBC,GAAhB,CAAnB;AACA,WAAO,KAAKZ,KAAL,CAAW+B,IAAX,CAAgBF,QAAQ,KAAKlB,UAAL,CAAgBkB,KAAKjB,GAArB,MAA8Be,UAAtD,CAAP;AACD;;AAEKzB,MAAN,GAAa;AAAA;;AAAA;AACX,YAAM8B,eAAe,MAAKhC,KAAL,CAAWiC,SAAX,CAAqB;AAAA,eAAM,CAAC,MAAKzB,KAAL,CAAW,MAAKG,UAAL,CAAgBuB,GAAGtB,GAAnB,CAAX,CAAP;AAAA,OAArB,CAArB;;AAEA,UAAIoB,iBAAiB,CAAC,CAAtB,EAAyB;AACvB;AACD;;AAED,YAAM,CAAC,EAAEpB,GAAF,EAAOP,OAAP,EAAD,IAAqB,MAAKL,KAAL,CAAWmC,MAAX,CAAkBH,YAAlB,EAAgC,CAAhC,CAA3B;AACA,YAAMI,UAAU,MAAKzB,UAAL,CAAgBC,GAAhB,CAAhB;AACA,YAAKJ,KAAL,CAAW4B,OAAX,IAAsB,IAAtB;;AAEA,UAAI;AACF,cAAMC,mBAAQC,SAAR,CAAkB,MAAK/B,WAAvB,EAAoC;AAAA,iBAAMgC,GAAG3B,GAAH,CAAN;AAAA,SAApC,CAAN;AACD,OAFD,CAEE,OAAO4B,GAAP,EAAY;AACZ,cAAK3C,MAAL,CAAY4C,IAAZ,CAAkB,GAAE,MAAK7C,IAAK,iCAAgC4C,IAAIE,OAAQ,EAA1E;;AAEA,YAAIrC,UAAU,CAAV,IAAe,MAAKP,OAAL,CAAaO,OAAhC,EAAyC;AACvC,gBAAKW,OAAL,CAAaJ,GAAb,EAAkBP,UAAU,CAA5B,EAA+B,IAA/B;AACD,SAFD,MAEO;AACL,gBAAKR,MAAL,CAAY8C,KAAZ,CACG,uBAAsB,MAAK/C,IAAK,iBAAgB,MAAKE,OAAL,CAAaO,OAAQ,6BADxE;AAGD;AACF,OAZD,SAYU;AACR,eAAO,MAAKG,KAAL,CAAW4B,OAAX,CAAP;AACA,YAAI,MAAKpC,KAAL,CAAWC,MAAf,EAAuB;AACrB,gBAAKC,IAAL;AACD;AACF;AA5BU;AA6BZ;;AAED0C,YAAUL,EAAV,EAAc;AACZ,SAAKhC,WAAL,CAAiBgB,IAAjB,CAAsBgB,EAAtB;AACD;AAvF8B;kBAAZ7C,W","file":"memory.js","sourcesContent":["import nanoid from 'nanoid'\nimport Promise from 'bluebird'\nimport _ from 'lodash'\n\nexport default class MemoryQueue {\n  constructor(name, logger, options = {}) {\n    this.name = name\n    this.logger = logger\n    this.options = Object.assign({ retries: 2, drainInterval: 2000 }, options)\n    this.queue = []\n    this.subscribers = []\n    this._lock = {}\n\n    this._drain = setInterval(this.drain, this.options.drainInterval)\n  }\n\n  drain = () => {\n    this.queue.length > 0 && this.tick()\n  }\n\n  getQueueId(job) {\n    const event = job.event || job\n\n    return (\n      _.get(event, 'user.id') ||\n      _.get(event, 'user.userId') ||\n      _.get(event, 'userId') ||\n      _.get(event, 'raw.user.id') ||\n      _.get(event, 'raw.userId') ||\n      _.get(event, 'raw.to') ||\n      'default'\n    )\n  }\n\n  enqueue(job, retries = 0, isPriority = false) {\n    const jobWrapped = { job, id: nanoid(), timestamp: new Date(), retries }\n    if (isPriority) {\n      this.queue.unshift(jobWrapped)\n    } else {\n      this.queue.push(jobWrapped)\n    }\n    this.tick()\n  }\n\n  dequeue() {\n    return this.queue.shift()\n  }\n\n  cancelAll(job) {\n    const jobQueueId = this.getQueueId(job)\n    this.queue = this.queue.filter(item => this.getQueueId(item.job) !== jobQueueId)\n  }\n\n  peek(job) {\n    const jobQueueId = this.getQueueId(job)\n    return this.queue.find(item => this.getQueueId(item.job) === jobQueueId)\n  }\n\n  async tick() {\n    const toDequeueIdx = this.queue.findIndex(el => !this._lock[this.getQueueId(el.job)])\n\n    if (toDequeueIdx === -1) {\n      return\n    }\n\n    const [{ job, retries }] = this.queue.splice(toDequeueIdx, 1)\n    const queueId = this.getQueueId(job)\n    this._lock[queueId] = true\n\n    try {\n      await Promise.mapSeries(this.subscribers, fn => fn(job))\n    } catch (err) {\n      this.logger.warn(`${this.name} queue failed to process job: ${err.message}`)\n\n      if (retries + 1 <= this.options.retries) {\n        this.enqueue(job, retries + 1, true)\n      } else {\n        this.logger.error(\n          `Retrying job within ${this.name} queue failed ${this.options.retries} times. Abandoning the job.`\n        )\n      }\n    } finally {\n      delete this._lock[queueId]\n      if (this.queue.length) {\n        this.tick()\n      }\n    }\n  }\n\n  subscribe(fn) {\n    this.subscribers.push(fn)\n  }\n}\n"]}