{"version":3,"sources":["../../src/renderers/engine.js"],"names":["ParsingError","Error","constructor","bloc","instructionIndex","error","internalMessage","captureStackTrace","premapInstruction","currentPlatform","instruction","index","instructions","detectedPlatforms","blocName","_","isArray","text","evaluate","val","exp","isArrayLike","isEmpty","isNil","if","unless","i","Object","assign","on","platforms","toLowerCase","split","map","trim","includes","isPlainObject","mapKeys","__","key","keys","forEach","indexOf","alias","trimmed","merge","mapInstruction","processors","incomingEvent","messages","ret","wait","push","__internal","type","isString","parseInt","typing","raw","omit","length","sample","processor","msg","event","mapBloc","options","throwIfNoPlatform","_premapInstruction","_mapInstruction","Array","add","m","message","renderMustache","template","context","Mustache","parse","render","hydrateMustache","obj","v","isObject","mapValues","module","exports","rendererName","rendererFn","rawBloc"],"mappings":"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","file":"engine.js","sourcesContent":["import Mustache from 'mustache'\nimport ms from 'ms'\nimport _ from 'lodash'\n\n// TODO: can use typed-error that handles stack capturing\nclass ParsingError extends Error {\n  constructor(bloc, instructionIndex, error) {\n    super(`Error parsing bloc '${bloc}' at instruction ${instructionIndex + 1}: ${error}`)\n    this.bloc = bloc\n    this.instructionIndex = instructionIndex\n    this.internalMessage = error\n    Error.captureStackTrace(this, ParsingError)\n  }\n}\n\nconst premapInstruction = ({ currentPlatform }) => ({\n  instruction,\n  index,\n  instructions,\n  detectedPlatforms,\n  blocName\n}) => {\n  if (typeof instruction === 'string' || _.isArray(instruction)) {\n    return [\n      {\n        text: instruction\n      }\n    ]\n  }\n\n  // Parsing conditionals\n  const evaluate = (val, exp) => {\n    if (typeof exp === 'boolean') {\n      return val === exp\n    }\n    if (_.isArrayLike(exp)) {\n      return val ? !_.isEmpty(exp) : _.isEmpty(exp)\n    } else {\n      return val ? !!exp : !exp\n    }\n  }\n\n  if (!_.isNil(instruction.if) && !_.isNil(instruction.unless)) {\n    throw new ParsingError(blocName, index, \"Message can't be both 'if' and 'else'.\")\n  }\n\n  if (!_.isNil(instruction.unless) && !evaluate(false, instruction.unless)) {\n    return []\n  }\n\n  if (!_.isNil(instruction.if) && !evaluate(true, instruction.if)) {\n    return []\n  }\n\n  // Parsing \".on\"\n  let i = Object.assign({}, instruction)\n  if (instruction.on) {\n    if (typeof instruction.on === 'string') {\n      const platforms = instruction.on\n        .toLowerCase()\n        .split('+')\n        .map(_.trim)\n      if (!_.includes(platforms, currentPlatform.toLowerCase())) {\n        return []\n      } else {\n        i['__platformSpecific'] = true\n      }\n    } else if (_.isPlainObject(instruction.on)) {\n      const on = _.mapKeys(instruction.on, (__, key) => key.toLowerCase())\n\n      // This allows multiple platforms to be specified\n      // e.g. \"messenger+slack+web\"\n      _.keys(on).forEach(key => {\n        if (key.indexOf('+') >= 0) {\n          _.split(key, '+').forEach(alias => {\n            const trimmed = _.trim(alias)\n            on[trimmed] = _.merge({}, on[trimmed] || {}, on[key])\n          })\n        }\n      })\n\n      i = Object.assign(i, on[currentPlatform.toLowerCase()], { on: currentPlatform })\n    } else {\n      throw new ParsingError(\n        blocName,\n        index,\n        '\"on\" must be a string or a plain object but was a ' + typeof instruction.on\n      )\n    }\n  }\n\n  return [i]\n}\n\nconst mapInstruction = ({ currentPlatform, processors, incomingEvent }) => ({ instruction, messages, blocName }) => {\n  const ret = []\n\n  if (!_.isNil(instruction.wait)) {\n    ret.push({\n      __internal: true,\n      type: 'wait',\n      wait: _.isString(instruction.wait) ? ms(instruction.wait || 1000) : parseInt(instruction.wait) || 1000\n    })\n  }\n\n  if (!_.isNil(instruction.typing)) {\n    instruction.typing = _.isString(instruction.typing)\n      ? ms(instruction.typing || 1000)\n      : parseInt(instruction.typing) || 1000\n  }\n\n  const raw = _.omit(instruction, ['unless', 'if', 'on', 'wait'])\n\n  if (!_.keys(raw).length) {\n    return ret\n  }\n\n  if (_.isArray(instruction.text)) {\n    instruction.text = _.sample(instruction.text)\n  }\n\n  const processor = currentPlatform && processors[currentPlatform]\n  if (processor) {\n    const msg = processor({ instruction, messages, blocName, event: incomingEvent })\n    if (msg) {\n      ret.push(msg)\n    }\n\n    return ret\n  }\n\n  throw new Error('Unsupported platform: ' + currentPlatform)\n}\n\nconst mapBloc = (bloc, blocName, options, processors, incomingEvent) => {\n  const { currentPlatform, throwIfNoPlatform = false } = options\n\n  if (!currentPlatform && throwIfNoPlatform) {\n    throw new Error('You need to supply `currentplatform`')\n  }\n\n  const _premapInstruction = premapInstruction({ currentPlatform })\n  const _mapInstruction = mapInstruction({ currentPlatform, processors, incomingEvent })\n\n  if (!Array.isArray(bloc)) {\n    bloc = [bloc]\n  }\n\n  const messages = []\n  const detectedPlatforms = []\n  const instructions = []\n\n  // Premapping allows for modifications, drop and addition of instructions\n  _.forEach(bloc, (instruction, index) => {\n    const add = _premapInstruction({\n      instruction,\n      index,\n      instructions: bloc,\n      detectedPlatforms,\n      blocName\n    })\n\n    add && _.forEach(add, i => instructions.push(i))\n  })\n\n  _.forEach(instructions, instruction => {\n    const m = _mapInstruction({ instruction, messages, blocName })\n\n    if (m != null) {\n      // Messages can be null when the instruction only modified existing messages\n      m.forEach(message => messages.push(message))\n    }\n  })\n\n  return messages\n}\n\nconst renderMustache = (template, context) => {\n  Mustache.parse(template)\n  return Mustache.render(template, context)\n}\n\nconst hydrateMustache = (obj, context) => {\n  if (_.isString(obj)) {\n    return renderMustache(obj, context)\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(v => hydrateMustache(v, context))\n  }\n  if (_.isObject(obj)) {\n    return _.mapValues(obj, v => hydrateMustache(v, context))\n  }\n  return obj\n}\n\nmodule.exports = async ({ rendererName, rendererFn, context, options, processors, incomingEvent }) => {\n  // We're running it a second time to do second-level variable replacement\n  // This happens often when there are variables used in the Content Manager\n  const rawBloc = hydrateMustache(hydrateMustache(await rendererFn(context), context), context)\n\n  return mapBloc(rawBloc, rendererName, options, processors, incomingEvent)\n}\n"]}