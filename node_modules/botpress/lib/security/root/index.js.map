{"version":3,"sources":["../../../src/security/root/index.js"],"names":["RootAuthentication","AbstractAuthenticationProvider","constructor","options","_bootstrapToken","attempts","secret","secretPath","path","join","dataLocation","createNewSecret","crypto","randomBytes","toString","fs","writeFileSync","existsSync","readFileSync","length","_buildToken","loginUser","jwt","sign","user","issuer","expiresIn","securityConfig","tokenExpiry","algorithm","_attempt","ip","maxAttempts","resetAfter","Date","lastCleanTimestamp","_login","password","adminPassword","process","env","BOTPRESS_ADMIN_PASSWORD","toLowerCase","id","username","email","first_name","last_name","avatar_url","roles","login","canAttempt","success","reason","token","authenticateWithError","authHeader","scheme","split","Error","decoded","verify","algorithms","identity_proof_only","getAuthenticationInfo","type","refreshToken","buildToken","err","message","getUserIdentity","getJWTSecretOrCertificate"],"mappings":"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","file":"index.js","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport crypto from 'crypto'\n\nimport jwt from 'jsonwebtoken'\n\nimport AbstractAuthenticationProvider from '../provider'\n\nexport default class RootAuthentication extends AbstractAuthenticationProvider {\n  constructor(options) {\n    super(options)\n\n    this._bootstrapToken()\n    this.attempts = {}\n  }\n\n  _bootstrapToken() {\n    let secret = ''\n    const secretPath = path.join(this.dataLocation, 'secret.key')\n\n    const createNewSecret = () => {\n      secret = crypto.randomBytes(256).toString()\n      fs.writeFileSync(secretPath, secret)\n      return secret\n    }\n\n    if (fs.existsSync(secretPath)) {\n      secret = fs.readFileSync(secretPath)\n    }\n\n    if (!secret || secret.length < 15) {\n      secret = createNewSecret()\n    }\n\n    this.secret = secret\n  }\n\n  async _buildToken(loginUser) {\n    return jwt.sign({ user: loginUser }, this.secret, {\n      issuer: 'bot.root',\n      expiresIn: this.securityConfig.tokenExpiry,\n      algorithm: 'HS256'\n    })\n  }\n\n  _attempt(ip) {\n    const { maxAttempts, resetAfter } = this.securityConfig\n\n    // reset the cache if time elapsed\n    if (new Date() - this.lastCleanTimestamp >= resetAfter) {\n      this.attempts = {}\n      this.lastCleanTimestamp = new Date()\n    }\n\n    return (this.attempts[ip] || 0) < maxAttempts\n  }\n\n  async _login(user, password, ip = 'all') {\n    const adminPassword = process.env.BOTPRESS_ADMIN_PASSWORD || this.securityConfig.password\n\n    if (\n      typeof user === 'string' &&\n      user.toLowerCase() === 'admin' &&\n      typeof password === 'string' &&\n      password === adminPassword\n    ) {\n      this.attempts[ip] = 0\n      return {\n        id: 0,\n        username: 'admin',\n        email: 'admin@botpress.io',\n        first_name: 'Admin',\n        last_name: 'Admin',\n        avatar_url: null,\n        roles: ['admin']\n      }\n    } else {\n      this.attempts[ip] = (this.attempts[ip] || 0) + 1\n      return null\n    }\n  }\n\n  async login(user, password, ip = 'all') {\n    const canAttempt = this._attempt(ip)\n    if (!canAttempt) {\n      return { success: false, reason: 'Too many login attempts. Try again later.' }\n    }\n\n    const loginUser = await this._login(user, password, ip)\n\n    if (loginUser) {\n      return {\n        success: true,\n        token: await this._buildToken(loginUser)\n      }\n    } else {\n      return {\n        success: false,\n        reason: 'Bad username / password'\n      }\n    }\n  }\n\n  async authenticateWithError(authHeader) {\n    const [scheme, token] = (authHeader || 'invalid header').split(' ')\n\n    if (scheme.toLowerCase() !== 'bearer') {\n      throw new Error(`Wrong scheme ${scheme}, expected Bearer`)\n    }\n\n    const decoded = jwt.verify(token, this.secret, { algorithms: ['HS256'] })\n\n    if (decoded.identity_proof_only) {\n      return false\n    }\n\n    return decoded.user\n  }\n\n  getAuthenticationInfo() {\n    return {\n      type: 'root'\n    }\n  }\n\n  async refreshToken(authHeader) {\n    try {\n      const loginUser = await this.authenticateWithError(authHeader)\n      return {\n        success: true,\n        token: await this.buildToken(loginUser)\n      }\n    } catch (err) {\n      return {\n        success: false,\n        reason: err.message || 'The token is invalid or expired'\n      }\n    }\n  }\n\n  async getUserIdentity(token) {\n    return this.authenticateWithError('bearer ' + token)\n  }\n\n  async getJWTSecretOrCertificate() {\n    return this.secret\n  }\n}\n"]}