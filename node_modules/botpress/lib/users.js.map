{"version":3,"sources":["../src/users.js"],"names":["module","exports","db","hasTag","userId","tag","knex","get","select","where","_","toUpper","limit","then","ret","length","value","update","tagged_on","date","now","insert","untag","del","getTag","details","Date","getTags","map","tags","v","list","from","isLite","TAG_VALUE_SEPARATOR","tagWithValue","parseTagValues","tagAndValue","split","selectTags","subQuery","raw","groupBy","leftJoin","toString","orderBy","offset","users","x","listWithTags","filter","isString","t","toUpperCase","filterByTag","query","i","forEach","name","join","Object","assign","count","parseInt"],"mappings":"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","file":"users.js","sourcesContent":["/**\n * The Users namespace contains operations available for the known users of your bot.\n * @public\n * @namespace Users\n * @example\n * bp.users\n */\n\nimport _ from 'lodash'\nimport helpers from './database/helpers'\n\nmodule.exports = ({ db }) => {\n  /**\n   * Returns whether or not a user has a specific tag or not.\n   * @param  {String} userId\n   * @param  {String} tag    The name of the tag. Case insensitive.\n   * @return {Boolean}\n   * @async\n   * @memberof! Users\n   * @example\n   * if (await bp.users.hasTag(event.user.id, 'IS_SUBSCRIBED')) {...}\n   */\n  const hasTag = async (userId, tag) => {\n    const knex = await db.get()\n\n    return knex('users_tags')\n      .select('userId')\n      .where({ userId, tag: _.toUpper(tag) })\n      .limit(1)\n      .then(ret => ret.length > 0)\n  }\n\n  /**\n   * Tags a user with a specific tag (or overwrites an existing one) and a given value for that tag (optional).\n   * Tags can be used to classify users (no value needed) or to store information about them (with a tag value).\n   * Values are useful to store user information like emails, etc.\n   * Value is always assumed to be a string.\n   * @param  {String}  userId\n   * @param  {String}  tag    The name of the tag.\n   * Case insensitive. Note that this property will always be upper-cased.\n   * @param  {String} [value]  Any string value to store info about this tag\n   * @async\n   * @memberof! Users\n   * @example\n   * await bp.users.tag(event.user.id, 'EMAIL', 'sylvain@botpress.io')\n   * await bp.users.tag(event.user.id, 'PAYING_USER')\n   */\n  const tag = async (userId, tag, value = true) => {\n    const knex = await db.get()\n\n    tag = _.toUpper(tag)\n\n    if (await hasTag(userId, tag)) {\n      await knex('users_tags')\n        .where({ userId, tag })\n        .update({\n          userId,\n          tag,\n          value,\n          tagged_on: helpers(knex).date.now()\n        })\n        .then()\n    } else {\n      await knex('users_tags')\n        .insert({\n          userId,\n          tag,\n          value,\n          tagged_on: helpers(knex).date.now()\n        })\n        .then()\n    }\n  }\n\n  /**\n   * Removes a tag from a user if it exists.\n   * @param  {String} userId\n   * @param  {String} tag    Name of the tag. Case-insensitive.\n   * @memberof! Users\n   */\n  const untag = async (userId, tag) => {\n    const knex = await db.get()\n\n    await knex('users_tags')\n      .where({ userId, tag: _.toUpper(tag) })\n      .del()\n      .then()\n  }\n\n  /**\n   * Returns the value of a user tag, if it exists\n   * @param  {String} userId [description]\n   * @param  {String} tag    [description]\n   * @return {?String}        Value of the tag\n   * @memberof! Users\n   */\n  const getTag = async (userId, tag, details = false) => {\n    const knex = await db.get()\n\n    return knex('users_tags')\n      .select('value', 'tagged_on', 'tag')\n      .where({ userId, tag: _.toUpper(tag) })\n      .limit(1)\n      .then()\n      .get(0)\n      .then(ret => {\n        if (ret && details) {\n          return {\n            ...ret,\n            tagged_on: new Date(ret.tagged_on)\n          }\n        }\n\n        return ret && ret.value\n      })\n  }\n\n  /**\n   * Returns all the tags for a given user\n   * @param  {String} userId [description]\n   * @return {Array.<{ tag: String, value: String}>}        An array of all the tags for this user\n   * @memberof! Users\n   */\n  const getTags = async userId => {\n    const knex = await db.get()\n\n    return knex('users_tags')\n      .where({ userId })\n      .select('tag', 'value')\n      .then(tags => {\n        return _.map(tags, v => {\n          return { tag: v.tag, value: v.value }\n        })\n      })\n  }\n\n  const list = async (limit = 50, from = 0) => {\n    const knex = await db.get()\n\n    const isLite = helpers(knex).isLite()\n\n    const TAG_VALUE_SEPARATOR = '::::'\n    const tagWithValue = `tag || '${TAG_VALUE_SEPARATOR}' || value`\n    const parseTagValues = tagAndValue => {\n      const [tag, value] = tagAndValue.split(TAG_VALUE_SEPARATOR)\n      return { tag, value }\n    }\n\n    const selectTags = isLite ? `group_concat(${tagWithValue}) as tags` : `string_agg(${tagWithValue}, ',') as tags`\n\n    const subQuery = knex('users_tags')\n      .select('userId', knex.raw(selectTags))\n      .groupBy('userId')\n\n    return knex('users')\n      .leftJoin(knex.raw('(' + subQuery.toString() + ') AS t2'), 'users.id', '=', 't2.userId')\n      .select(\n        'users.id',\n        'users.userId',\n        'users.platform',\n        'users.gender',\n        'users.timezone',\n        'users.locale',\n        'users.picture_url',\n        'users.first_name',\n        'users.last_name',\n        'users.created_on',\n        't2.tags'\n      )\n      .orderBy('users.created_on', 'asc')\n      .offset(from)\n      .limit(limit)\n      .then(users =>\n        users.map(x => ({\n          ...x,\n          tags: (x.tags && x.tags.split(',').map(parseTagValues)) || []\n        }))\n      )\n  }\n\n  // TODO: Fix this, just doesn't work\n  const listWithTags = async (tags, limit = 50, from = 0) => {\n    const knex = await db.get()\n\n    tags = _.filter(tags, t => _.isString(t)).map(t => t.toUpperCase())\n    const filterByTag = tag =>\n      knex('users_tags')\n        .select('userId')\n        .where('tag', tag)\n\n    const isLite = helpers(knex).isLite()\n    const selectTags = isLite ? 'group_concat(tag) as tags' : \"string_agg(tag, ',') as tags\"\n\n    let query = knex('users')\n    let i = 0\n\n    const subQuery = knex('users_tags')\n      .select('userId', knex.raw(selectTags))\n      .groupBy('userId')\n\n    tags.forEach(tag => {\n      const name = 't' + ++i\n      query = query.join(\n        knex.raw('(' + filterByTag(tag).toString() + ') AS ' + name),\n        'users.id',\n        '=',\n        name + '.userId'\n      )\n    })\n\n    return query\n      .leftJoin(knex.raw('(' + subQuery.toString() + ') AS tt'), 'users.id', '=', 'tt.userId')\n      .select(\n        'users.userId as userId',\n        'users.platform as platform',\n        'users.gender as gender',\n        'users.timezone as timezone',\n        'users.locale as locale',\n        'users.picture_url as picture_url',\n        'users.first_name as first_name',\n        'users.last_name as last_name',\n        'users.created_on as created_on',\n        'tt.tags as tags'\n      )\n      .orderBy('users.created_on', 'asc')\n      .offset(from)\n      .limit(limit)\n      .then(users =>\n        users.map(x =>\n          Object.assign(x, {\n            tags: (x.tags && x.tags.split(',')) || []\n          })\n        )\n      )\n  }\n\n  const count = async () => {\n    const knex = await db.get()\n\n    return knex('users')\n      .count('* as count')\n      .then()\n      .get(0)\n      .then(ret => parseInt(ret && ret.count))\n  }\n\n  return { tag, untag, hasTag, getTag, getTags, list, count, listWithTags }\n}\n"]}